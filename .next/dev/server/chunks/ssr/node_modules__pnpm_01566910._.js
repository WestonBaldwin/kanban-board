module.exports = [
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}),
"[project]/node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/cjs/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.jwtDecode = exports.InvalidTokenError = void 0;
class InvalidTokenError extends Error {
}
exports.InvalidTokenError = InvalidTokenError;
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p)=>{
        let code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
            code = "0" + code;
        }
        return "%" + code;
    }));
}
function base64UrlDecode(str) {
    let output = str.replace(/-/g, "+").replace(/_/g, "/");
    switch(output.length % 4){
        case 0:
            break;
        case 2:
            output += "==";
            break;
        case 3:
            output += "=";
            break;
        default:
            throw new Error("base64 string is not of the correct length");
    }
    try {
        return b64DecodeUnicode(output);
    } catch (err) {
        return atob(output);
    }
}
function jwtDecode(token, options) {
    if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified: must be a string");
    }
    options || (options = {});
    const pos = options.header === true ? 0 : 1;
    const part = token.split(".")[pos];
    if (typeof part !== "string") {
        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
    }
    let decoded;
    try {
        decoded = base64UrlDecode(part);
    } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
    }
    try {
        return JSON.parse(decoded);
    } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
    }
}
exports.jwtDecode = jwtDecode;
}),
"[project]/node_modules/.pnpm/js-cookie@3.0.5/node_modules/js-cookie/dist/js.cookie.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! js-cookie v3.0.5 | MIT */ ;
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    'use strict';
    /* eslint-disable no-var */ function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                target[key] = source[key];
            }
        }
        return target;
    }
    /* eslint-enable no-var */ /* eslint-disable no-var */ var defaultConverter = {
        read: function(value) {
            if (value[0] === '"') {
                value = value.slice(1, -1);
            }
            return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
        },
        write: function(value) {
            return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
        }
    };
    /* eslint-enable no-var */ /* eslint-disable no-var */ function init(converter, defaultAttributes) {
        function set(name, value, attributes) {
            if (typeof document === 'undefined') {
                return;
            }
            attributes = assign({}, defaultAttributes, attributes);
            if (typeof attributes.expires === 'number') {
                attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
            }
            if (attributes.expires) {
                attributes.expires = attributes.expires.toUTCString();
            }
            name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var stringifiedAttributes = '';
            for(var attributeName in attributes){
                if (!attributes[attributeName]) {
                    continue;
                }
                stringifiedAttributes += '; ' + attributeName;
                if (attributes[attributeName] === true) {
                    continue;
                }
                // Considers RFC 6265 section 5.2:
                // ...
                // 3.  If the remaining unparsed-attributes contains a %x3B (";")
                //     character:
                // Consume the characters of the unparsed-attributes up to,
                // not including, the first %x3B (";") character.
                // ...
                stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
            }
            return document.cookie = name + '=' + converter.write(value, name) + stringifiedAttributes;
        }
        function get(name) {
            if (typeof document === 'undefined' || arguments.length && !name) {
                return;
            }
            // To prevent the for loop in the first place assign an empty array
            // in case there are no cookies at all.
            var cookies = document.cookie ? document.cookie.split('; ') : [];
            var jar = {};
            for(var i = 0; i < cookies.length; i++){
                var parts = cookies[i].split('=');
                var value = parts.slice(1).join('=');
                try {
                    var found = decodeURIComponent(parts[0]);
                    jar[found] = converter.read(value, found);
                    if (name === found) {
                        break;
                    }
                } catch (e) {}
            }
            return name ? jar[name] : jar;
        }
        return Object.create({
            set,
            get,
            remove: function(name, attributes) {
                set(name, '', assign({}, attributes, {
                    expires: -1
                }));
            },
            withAttributes: function(attributes) {
                return init(this.converter, assign({}, this.attributes, attributes));
            },
            withConverter: function(converter) {
                return init(assign({}, this.converter, converter), this.attributes);
            }
        }, {
            attributes: {
                value: Object.freeze(defaultAttributes)
            },
            converter: {
                value: Object.freeze(converter)
            }
        });
    }
    var api = init(defaultConverter, {
        path: '/'
    });
    /* eslint-enable no-var */ return api;
});
}),
"[project]/node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var conversions = {};
module.exports = conversions;
function sign(x) {
    return x < 0 ? -1 : 1;
}
function evenRound(x) {
    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
    if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
    } else {
        return Math.round(x);
    }
}
function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
        --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;
    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw new TypeError("Argument is not a finite number");
            }
            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
                throw new TypeError("Argument is not in byte range");
            }
            return x;
        }
        if (!isNaN(x) && opts.clamp) {
            x = evenRound(x);
            if (x < lowerBound) x = lowerBound;
            if (x > upperBound) x = upperBound;
            return x;
        }
        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
        } else if (typeOpts.unsigned) {
            if (x < 0) {
                x += moduloVal;
            } else if (x === -0) {
                return 0;
            }
        }
        return x;
    };
}
conversions["void"] = function() {
    return undefined;
};
conversions["boolean"] = function(val) {
    return !!val;
};
conversions["byte"] = createNumberConversion(8, {
    unsigned: false
});
conversions["octet"] = createNumberConversion(8, {
    unsigned: true
});
conversions["short"] = createNumberConversion(16, {
    unsigned: false
});
conversions["unsigned short"] = createNumberConversion(16, {
    unsigned: true
});
conversions["long"] = createNumberConversion(32, {
    unsigned: false
});
conversions["unsigned long"] = createNumberConversion(32, {
    unsigned: true
});
conversions["long long"] = createNumberConversion(32, {
    unsigned: false,
    moduloBitLength: 64
});
conversions["unsigned long long"] = createNumberConversion(32, {
    unsigned: true,
    moduloBitLength: 64
});
conversions["double"] = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
    }
    return x;
};
conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
    }
    return x;
};
// not quite valid, but good enough for JS
conversions["float"] = conversions["double"];
conversions["unrestricted float"] = conversions["unrestricted double"];
conversions["DOMString"] = function(V, opts) {
    if (!opts) opts = {};
    if (opts.treatNullAsEmptyString && V === null) {
        return "";
    }
    return String(V);
};
conversions["ByteString"] = function(V, opts) {
    const x = String(V);
    let c = undefined;
    for(let i = 0; (c = x.codePointAt(i)) !== undefined; ++i){
        if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
        }
    }
    return x;
};
conversions["USVString"] = function(V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for(let i = 0; i < n; ++i){
        const c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) {
            U.push(String.fromCodePoint(c));
        } else if (0xDC00 <= c && c <= 0xDFFF) {
            U.push(String.fromCodePoint(0xFFFD));
        } else {
            if (i === n - 1) {
                U.push(String.fromCodePoint(0xFFFD));
            } else {
                const d = S.charCodeAt(i + 1);
                if (0xDC00 <= d && d <= 0xDFFF) {
                    const a = c & 0x3FF;
                    const b = d & 0x3FF;
                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                    ++i;
                } else {
                    U.push(String.fromCodePoint(0xFFFD));
                }
            }
        }
    }
    return U.join('');
};
conversions["Date"] = function(V, opts) {
    if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
        return undefined;
    }
    return V;
};
conversions["RegExp"] = function(V, opts) {
    if (!(V instanceof RegExp)) {
        V = new RegExp(V);
    }
    return V;
};
}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports.mixin = function mixin(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for(let i = 0; i < keys.length; ++i){
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }
};
module.exports.wrapperSymbol = Symbol("wrapper");
module.exports.implSymbol = Symbol("impl");
module.exports.wrapperForImpl = function(impl) {
    return impl[module.exports.wrapperSymbol];
};
module.exports.implForWrapper = function(wrapper) {
    return wrapper[module.exports.implSymbol];
};
}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const punycode = __turbopack_context__.r("[externals]/punycode [external] (punycode, cjs)");
const tr46 = __turbopack_context__.r("[project]/node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js [app-ssr] (ecmascript)");
const specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
const failure = Symbol("failure");
function countSymbols(str) {
    return punycode.ucs2.decode(str).length;
}
function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
}
function isASCIIDigit(c) {
    return c >= 0x30 && c <= 0x39;
}
function isASCIIAlpha(c) {
    return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;
}
function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
}
function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;
}
function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
}
function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
}
function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
}
function isWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
}
function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
}
function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
}
function containsForbiddenHostCodePointExcludingPercent(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
}
function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== undefined;
}
function isSpecial(url) {
    return isSpecialScheme(url.scheme);
}
function defaultPort(scheme) {
    return specialSchemes[scheme];
}
function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
        hex = "0" + hex;
    }
    return "%" + hex;
}
function utf8PercentEncode(c) {
    const buf = new Buffer(c);
    let str = "";
    for(let i = 0; i < buf.length; ++i){
        str += percentEncode(buf[i]);
    }
    return str;
}
function utf8PercentDecode(str) {
    const input = new Buffer(str);
    const output = [];
    for(let i = 0; i < input.length; ++i){
        if (input[i] !== 37) {
            output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
            output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
            i += 2;
        } else {
            output.push(input[i]);
        }
    }
    return new Buffer(output).toString();
}
function isC0ControlPercentEncode(c) {
    return c <= 0x1F || c > 0x7E;
}
const extraPathPercentEncodeSet = new Set([
    32,
    34,
    35,
    60,
    62,
    63,
    96,
    123,
    125
]);
function isPathPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
}
const extraUserinfoPercentEncodeSet = new Set([
    47,
    58,
    59,
    61,
    64,
    91,
    92,
    93,
    94,
    124
]);
function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
}
function percentEncodeChar(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
    }
    return cStr;
}
function parseIPv4Number(input) {
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
    }
    if (input === "") {
        return 0;
    }
    const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
    if (regex.test(input)) {
        return failure;
    }
    return parseInt(input, R);
}
function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
            parts.pop();
        }
    }
    if (parts.length > 4) {
        return input;
    }
    const numbers = [];
    for (const part of parts){
        if (part === "") {
            return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
            return input;
        }
        numbers.push(n);
    }
    for(let i = 0; i < numbers.length - 1; ++i){
        if (numbers[i] > 255) {
            return failure;
        }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers){
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
    }
    return ipv4;
}
function serializeIPv4(address) {
    let output = "";
    let n = address;
    for(let i = 1; i <= 4; ++i){
        output = String(n % 256) + output;
        if (i !== 4) {
            output = "." + output;
        }
        n = Math.floor(n / 256);
    }
    return output;
}
function parseIPv6(input) {
    const address = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = punycode.ucs2.decode(input);
    if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
            return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
    }
    while(pointer < input.length){
        if (pieceIndex === 8) {
            return failure;
        }
        if (input[pointer] === 58) {
            if (compress !== null) {
                return failure;
            }
            ++pointer;
            ++pieceIndex;
            compress = pieceIndex;
            continue;
        }
        let value = 0;
        let length = 0;
        while(length < 4 && isASCIIHex(input[pointer])){
            value = value * 0x10 + parseInt(at(input, pointer), 16);
            ++pointer;
            ++length;
        }
        if (input[pointer] === 46) {
            if (length === 0) {
                return failure;
            }
            pointer -= length;
            if (pieceIndex > 6) {
                return failure;
            }
            let numbersSeen = 0;
            while(input[pointer] !== undefined){
                let ipv4Piece = null;
                if (numbersSeen > 0) {
                    if (input[pointer] === 46 && numbersSeen < 4) {
                        ++pointer;
                    } else {
                        return failure;
                    }
                }
                if (!isASCIIDigit(input[pointer])) {
                    return failure;
                }
                while(isASCIIDigit(input[pointer])){
                    const number = parseInt(at(input, pointer));
                    if (ipv4Piece === null) {
                        ipv4Piece = number;
                    } else if (ipv4Piece === 0) {
                        return failure;
                    } else {
                        ipv4Piece = ipv4Piece * 10 + number;
                    }
                    if (ipv4Piece > 255) {
                        return failure;
                    }
                    ++pointer;
                }
                address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;
                ++numbersSeen;
                if (numbersSeen === 2 || numbersSeen === 4) {
                    ++pieceIndex;
                }
            }
            if (numbersSeen !== 4) {
                return failure;
            }
            break;
        } else if (input[pointer] === 58) {
            ++pointer;
            if (input[pointer] === undefined) {
                return failure;
            }
        } else if (input[pointer] !== undefined) {
            return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
    }
    if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while(pieceIndex !== 0 && swaps > 0){
            const temp = address[compress + swaps - 1];
            address[compress + swaps - 1] = address[pieceIndex];
            address[pieceIndex] = temp;
            --pieceIndex;
            --swaps;
        }
    } else if (compress === null && pieceIndex !== 8) {
        return failure;
    }
    return address;
}
function serializeIPv6(address) {
    let output = "";
    const seqResult = findLongestZeroSequence(address);
    const compress = seqResult.idx;
    let ignore0 = false;
    for(let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex){
        if (ignore0 && address[pieceIndex] === 0) {
            continue;
        } else if (ignore0) {
            ignore0 = false;
        }
        if (compress === pieceIndex) {
            const separator = pieceIndex === 0 ? "::" : ":";
            output += separator;
            ignore0 = true;
            continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
            output += ":";
        }
    }
    return output;
}
function parseHost(input, isSpecialArg) {
    if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
            return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
    }
    if (!isSpecialArg) {
        return parseOpaqueHost(input);
    }
    const domain = utf8PercentDecode(input);
    const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
    if (asciiDomain === null) {
        return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
    }
    const ipv4Host = parseIPv4(asciiDomain);
    if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
    }
    return asciiDomain;
}
function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
    }
    let output = "";
    const decoded = punycode.ucs2.decode(input);
    for(let i = 0; i < decoded.length; ++i){
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
    }
    return output;
}
function findLongestZeroSequence(arr) {
    let maxIdx = null;
    let maxLen = 1; // only find elements > 1
    let currStart = null;
    let currLen = 0;
    for(let i = 0; i < arr.length; ++i){
        if (arr[i] !== 0) {
            if (currLen > maxLen) {
                maxIdx = currStart;
                maxLen = currLen;
            }
            currStart = null;
            currLen = 0;
        } else {
            if (currStart === null) {
                currStart = i;
            }
            ++currLen;
        }
    }
    // if trailing zeros
    if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
    }
    return {
        idx: maxIdx,
        len: maxLen
    };
}
function serializeHost(host) {
    if (typeof host === "number") {
        return serializeIPv4(host);
    }
    // IPv6 serializer
    if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
    }
    return host;
}
function trimControlChars(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
}
function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/g, "");
}
function shortenPath(url) {
    const path = url.path;
    if (path.length === 0) {
        return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
    }
    path.pop();
}
function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
}
function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
}
function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/.test(string);
}
function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
        this.url = {
            scheme: "",
            username: "",
            password: "",
            host: null,
            port: null,
            path: [],
            query: null,
            fragment: null,
            cannotBeABaseURL: false
        };
        const res = trimControlChars(this.input);
        if (res !== this.input) {
            this.parseError = true;
        }
        this.input = res;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
        this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = punycode.ucs2.decode(this.input);
    for(; this.pointer <= this.input.length; ++this.pointer){
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
        // exec state machine
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
            break; // terminate algorithm
        } else if (ret === failure) {
            this.failure = true;
            break;
        }
    }
}
URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
    } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
    } else if (c === 58) {
        if (this.stateOverride) {
            if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
                return false;
            }
            if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
                return false;
            }
            if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
                return false;
            }
            if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
                return false;
            }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
            return false;
        }
        if (this.url.scheme === "file") {
            if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
                this.parseError = true;
            }
            this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
            this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
            this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
            this.state = "path or authority";
            ++this.pointer;
        } else {
            this.url.cannotBeABaseURL = true;
            this.url.path.push("");
            this.state = "cannot-be-a-base-URL path";
        }
    } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
    } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
    } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
    } else {
        this.state = "relative";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
    } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === 47) {
        this.state = "authority";
    } else {
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
    } else if (c === 47) {
        this.state = "relative slash";
    } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
    } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
    } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
    } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "special authority ignore slashes";
    } else if (c === 47) {
        this.state = "authority";
    } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
    } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
    } else {
        this.parseError = true;
    }
    return true;
};
URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
            this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
        const len = countSymbols(this.buffer);
        for(let pointer = 0; pointer < len; ++pointer){
            const codePoint = this.buffer.codePointAt(pointer);
            if (codePoint === 58 && !this.passwordTokenSeenFlag) {
                this.passwordTokenSeenFlag = true;
                continue;
            }
            const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
            if (this.passwordTokenSeenFlag) {
                this.url.password += encodedCodePoints;
            } else {
                this.url.username += encodedCodePoints;
            }
        }
        this.buffer = "";
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
            this.parseError = true;
            return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
    } else {
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
    } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
            this.parseError = true;
            return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
            return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
            return false;
        }
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
            this.parseError = true;
            return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
            this.parseError = true;
            return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
            return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
            return false;
        }
    } else {
        if (c === 91) {
            this.arrFlag = true;
        } else if (c === 93) {
            this.arrFlag = false;
        }
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (isASCIIDigit(c)) {
        this.buffer += cStr;
    } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
            const port = parseInt(this.buffer);
            if (port > Math.pow(2, 16) - 1) {
                this.parseError = true;
                return failure;
            }
            this.url.port = port === defaultPort(this.url.scheme) ? null : port;
            this.buffer = "";
        }
        if (this.stateOverride) {
            return false;
        }
        this.state = "path start";
        --this.pointer;
    } else {
        this.parseError = true;
        return failure;
    }
    return true;
};
const fileOtherwiseCodePoints = new Set([
    47,
    92,
    63,
    35
]);
URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    if (c === 47 || c === 92) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
        } else if (c === 63) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = "";
            this.state = "query";
        } else if (c === 35) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
            this.url.fragment = "";
            this.state = "fragment";
        } else {
            if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
            !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                shortenPath(this.url);
            } else {
                this.parseError = true;
            }
            this.state = "path";
            --this.pointer;
        }
    } else {
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === 47 || c === 92) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "file host";
    } else {
        if (this.base !== null && this.base.scheme === "file") {
            if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
                this.url.path.push(this.base.path[0]);
            } else {
                this.url.host = this.base.host;
            }
        }
        this.state = "path";
        --this.pointer;
    }
    return true;
};
URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
            this.parseError = true;
            this.state = "path";
        } else if (this.buffer === "") {
            this.url.host = "";
            if (this.stateOverride) {
                return false;
            }
            this.state = "path start";
        } else {
            let host = parseHost(this.buffer, isSpecial(this.url));
            if (host === failure) {
                return failure;
            }
            if (host === "localhost") {
                host = "";
            }
            this.url.host = host;
            if (this.stateOverride) {
                return false;
            }
            this.buffer = "";
            this.state = "path start";
        }
    } else {
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
        if (c === 92) {
            this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
            --this.pointer;
        }
    } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
    } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
    } else if (c !== undefined) {
        this.state = "path";
        if (c !== 47) {
            --this.pointer;
        }
    }
    return true;
};
URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
            this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
            shortenPath(this.url);
            if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
                this.url.path.push("");
            }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
            if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
                if (this.url.host !== "" && this.url.host !== null) {
                    this.parseError = true;
                    this.url.host = "";
                }
                this.buffer = this.buffer[0] + ":";
            }
            this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
            while(this.url.path.length > 1 && this.url.path[0] === ""){
                this.parseError = true;
                this.url.path.shift();
            }
        }
        if (c === 63) {
            this.url.query = "";
            this.state = "query";
        }
        if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
        }
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
    }
    return true;
};
URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
    if (c === 63) {
        this.url.query = "";
        this.state = "query";
    } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
    } else {
        // TODO: Add: not a URL code point
        if (!isNaN(c) && c !== 37) {
            this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        if (!isNaN(c)) {
            this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
    }
    return true;
};
URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
            this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
        for(let i = 0; i < buffer.length; ++i){
            if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 || buffer[i] === 0x3C || buffer[i] === 0x3E) {
                this.url.query += percentEncode(buffer[i]);
            } else {
                this.url.query += String.fromCodePoint(buffer[i]);
            }
        }
        this.buffer = "";
        if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
        }
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.buffer += cStr;
    }
    return true;
};
URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (isNaN(c)) {} else if (c === 0x0) {
        this.parseError = true;
    } else {
        // TODO: If c is not a URL code point and not "%", parse error.
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
    }
    return true;
};
function serializeURL(url, excludeFragment) {
    let output = url.scheme + ":";
    if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
            output += url.username;
            if (url.password !== "") {
                output += ":" + url.password;
            }
            output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
            output += ":" + url.port;
        }
    } else if (url.host === null && url.scheme === "file") {
        output += "//";
    }
    if (url.cannotBeABaseURL) {
        output += url.path[0];
    } else {
        for (const string of url.path){
            output += "/" + string;
        }
    }
    if (url.query !== null) {
        output += "?" + url.query;
    }
    if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
    }
    return output;
}
function serializeOrigin(tuple) {
    let result = tuple.scheme + "://";
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
        result += ":" + tuple.port;
    }
    return result;
}
module.exports.serializeURL = serializeURL;
module.exports.serializeURLOrigin = function(url) {
    // https://url.spec.whatwg.org/#concept-url-origin
    switch(url.scheme){
        case "blob":
            try {
                return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
            } catch (e) {
                // serializing an opaque origin returns "null"
                return "null";
            }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
            return serializeOrigin({
                scheme: url.scheme,
                host: url.host,
                port: url.port
            });
        case "file":
            // spec says "exercise to the reader", chrome says "file://"
            return "file://";
        default:
            // serializing an opaque origin returns "null"
            return "null";
    }
};
module.exports.basicURLParse = function(input, options) {
    if (options === undefined) {
        options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
        return "failure";
    }
    return usm.url;
};
module.exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for(let i = 0; i < decoded.length; ++i){
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
};
module.exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for(let i = 0; i < decoded.length; ++i){
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
    }
};
module.exports.serializeHost = serializeHost;
module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
module.exports.serializeInteger = function(integer) {
    return String(integer);
};
module.exports.parseURL = function(input, options) {
    if (options === undefined) {
        options = {};
    }
    // We don't handle blobs, so this just delegates:
    return module.exports.basicURLParse(input, {
        baseURL: options.baseURL,
        encodingOverride: options.encodingOverride
    });
};
}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const usm = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)");
exports.implementation = class URLImpl {
    constructor(constructorArgs){
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== undefined) {
            parsedBase = usm.basicURLParse(base);
            if (parsedBase === "failure") {
                throw new TypeError("Invalid base URL");
            }
        }
        const parsedURL = usm.basicURLParse(url, {
            baseURL: parsedBase
        });
        if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
    // TODO: query stuff
    }
    get href() {
        return usm.serializeURL(this._url);
    }
    set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
    }
    get origin() {
        return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
        return this._url.scheme + ":";
    }
    set protocol(v) {
        usm.basicURLParse(v + ":", {
            url: this._url,
            stateOverride: "scheme start"
        });
    }
    get username() {
        return this._url.username;
    }
    set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        usm.setTheUsername(this._url, v);
    }
    get password() {
        return this._url.password;
    }
    set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        usm.setThePassword(this._url, v);
    }
    get host() {
        const url = this._url;
        if (url.host === null) {
            return "";
        }
        if (url.port === null) {
            return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "host"
        });
    }
    get hostname() {
        if (this._url.host === null) {
            return "";
        }
        return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "hostname"
        });
    }
    get port() {
        if (this._url.port === null) {
            return "";
        }
        return usm.serializeInteger(this._url.port);
    }
    set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
        }
        if (v === "") {
            this._url.port = null;
        } else {
            usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "port"
            });
        }
    }
    get pathname() {
        if (this._url.cannotBeABaseURL) {
            return this._url.path[0];
        }
        if (this._url.path.length === 0) {
            return "";
        }
        return "/" + this._url.path.join("/");
    }
    set pathname(v) {
        if (this._url.cannotBeABaseURL) {
            return;
        }
        this._url.path = [];
        usm.basicURLParse(v, {
            url: this._url,
            stateOverride: "path start"
        });
    }
    get search() {
        if (this._url.query === null || this._url.query === "") {
            return "";
        }
        return "?" + this._url.query;
    }
    set search(v) {
        // TODO: query stuff
        const url = this._url;
        if (v === "") {
            url.query = null;
            return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, {
            url,
            stateOverride: "query"
        });
    }
    get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
            return "";
        }
        return "#" + this._url.fragment;
    }
    set hash(v) {
        if (v === "") {
            this._url.fragment = null;
            return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, {
            url: this._url,
            stateOverride: "fragment"
        });
    }
    toJSON() {
        return this.href;
    }
};
}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const conversions = __turbopack_context__.r("[project]/node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js [app-ssr] (ecmascript)");
const utils = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js [app-ssr] (ecmascript)");
const Impl = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js [app-ssr] (ecmascript)");
const impl = utils.implSymbol;
function URL(url) {
    if (!this || this[impl] || !(this instanceof URL)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    }
    if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    }
    const args = [];
    for(let i = 0; i < arguments.length && i < 2; ++i){
        args[i] = arguments[i];
    }
    args[0] = conversions["USVString"](args[0]);
    if (args[1] !== undefined) {
        args[1] = conversions["USVString"](args[1]);
    }
    module.exports.setup(this, args);
}
URL.prototype.toJSON = function toJSON() {
    if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
    }
    const args = [];
    for(let i = 0; i < arguments.length && i < 0; ++i){
        args[i] = arguments[i];
    }
    return this[impl].toJSON.apply(this[impl], args);
};
Object.defineProperty(URL.prototype, "href", {
    get () {
        return this[impl].href;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
    },
    enumerable: true,
    configurable: true
});
URL.prototype.toString = function() {
    if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
    }
    return this.href;
};
Object.defineProperty(URL.prototype, "origin", {
    get () {
        return this[impl].origin;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "protocol", {
    get () {
        return this[impl].protocol;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "username", {
    get () {
        return this[impl].username;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "password", {
    get () {
        return this[impl].password;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "host", {
    get () {
        return this[impl].host;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "hostname", {
    get () {
        return this[impl].hostname;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "port", {
    get () {
        return this[impl].port;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "pathname", {
    get () {
        return this[impl].pathname;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "search", {
    get () {
        return this[impl].search;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
    },
    enumerable: true,
    configurable: true
});
Object.defineProperty(URL.prototype, "hash", {
    get () {
        return this[impl].hash;
    },
    set (V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
    },
    enumerable: true,
    configurable: true
});
module.exports = {
    is (obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
    },
    create (constructorArgs, privateData) {
        let obj = Object.create(URL.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
    },
    setup (obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
    },
    interface: URL,
    expose: {
        Window: {
            URL: URL
        },
        Worker: {
            URL: URL
        }
    }
};
}),
"[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.URL = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js [app-ssr] (ecmascript)").interface;
exports.serializeURL = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").serializeURL;
exports.serializeURLOrigin = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").serializeURLOrigin;
exports.basicURLParse = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").basicURLParse;
exports.setTheUsername = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").setTheUsername;
exports.setThePassword = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").setThePassword;
exports.serializeHost = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").serializeHost;
exports.serializeInteger = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").serializeInteger;
exports.parseURL = __turbopack_context__.r("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js [app-ssr] (ecmascript)").parseURL;
}),
"[project]/node_modules/.pnpm/node-fetch@2.6.13/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FetchError",
    ()=>FetchError,
    "Headers",
    ()=>Headers,
    "Request",
    ()=>Request,
    "Response",
    ()=>Response,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/http [external] (http, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/https [external] (https, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/zlib [external] (zlib, cjs)");
;
;
;
;
;
;
// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js
// fix for "Readable" isn't a named export issue
const Readable = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable;
const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');
class Blob {
    constructor(){
        this[TYPE] = '';
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for(let i = 0; i < length; i++){
                const element = a[i];
                let buffer;
                if (element instanceof Buffer) {
                    buffer = element;
                } else if (ArrayBuffer.isView(element)) {
                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                } else if (element instanceof ArrayBuffer) {
                    buffer = Buffer.from(element);
                } else if (element instanceof Blob) {
                    buffer = element[BUFFER];
                } else {
                    buffer = Buffer.from(typeof element === 'string' ? element : String(element));
                }
                size += buffer.length;
                buffers.push(buffer);
            }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== undefined && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
            this[TYPE] = type;
        }
    }
    get size() {
        return this[BUFFER].length;
    }
    get type() {
        return this[TYPE];
    }
    text() {
        return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
    }
    stream() {
        const readable = new Readable();
        readable._read = function() {};
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
    }
    toString() {
        return '[object Blob]';
    }
    slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === undefined) {
            relativeStart = 0;
        } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
        } else {
            relativeStart = Math.min(start, size);
        }
        if (end === undefined) {
            relativeEnd = size;
        } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
        } else {
            relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], {
            type: arguments[2]
        });
        blob[BUFFER] = slicedBuffer;
        return blob;
    }
}
Object.defineProperties(Blob.prototype, {
    size: {
        enumerable: true
    },
    type: {
        enumerable: true
    },
    slice: {
        enumerable: true
    }
});
Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: 'Blob',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */ /**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */ function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    // when err.type is `system`, err.code contains system error code
    if (systemError) {
        this.code = this.errno = systemError.code;
    }
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';
let convert;
try {
    convert = (()=>{
        const e = new Error("Cannot find module 'encoding'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })().convert;
} catch (e) {}
const INTERNALS = Symbol('Body internals');
// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
        // body is undefined or null
        body = null;
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        body = Buffer.from(body.toString());
    } else if (isBlob(body)) ;
    else if (Buffer.isBuffer(body)) ;
    else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) ;
    else {
        // none of the above
        // coerce to string then buffer
        body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        body.on('error', function(err) {
            const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
            _this[INTERNALS].error = error;
        });
    }
}
Body.prototype = {
    get body () {
        return this[INTERNALS].body;
    },
    get bodyUsed () {
        return this[INTERNALS].disturbed;
    },
    /**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */ arrayBuffer () {
        return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
    },
    /**
  * Return raw response as Blob
  *
  * @return Promise
  */ blob () {
        let ct = this.headers && this.headers.get('content-type') || '';
        return consumeBody.call(this).then(function(buf) {
            return Object.assign(// Prevent copying
            new Blob([], {
                type: ct.toLowerCase()
            }), {
                [BUFFER]: buf
            });
        });
    },
    /**
  * Decode response as json
  *
  * @return  Promise
  */ json () {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
            try {
                return JSON.parse(buffer.toString());
            } catch (err) {
                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
            }
        });
    },
    /**
  * Decode response as text
  *
  * @return  Promise
  */ text () {
        return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
        });
    },
    /**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */ buffer () {
        return consumeBody.call(this);
    },
    /**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */ textConverted () {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
        });
    }
};
// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
    body: {
        enumerable: true
    },
    bodyUsed: {
        enumerable: true
    },
    arrayBuffer: {
        enumerable: true
    },
    blob: {
        enumerable: true
    },
    json: {
        enumerable: true
    },
    text: {
        enumerable: true
    }
});
Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)){
        // istanbul ignore else: future proof
        if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
        }
    }
};
/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */ function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    // body is null
    if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is blob
    if (isBlob(body)) {
        body = body.stream();
    }
    // body is buffer
    if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
    }
    // istanbul ignore if: should never happen
    if (!(body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"])) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is stream
    // get ready to actually consume the body
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        // allow timeout on slow response body
        if (_this4.timeout) {
            resTimeout = setTimeout(function() {
                abort = true;
                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
            }, _this4.timeout);
        }
        // handle stream errors
        body.on('error', function(err) {
            if (err.name === 'AbortError') {
                // if the request was aborted, reject with this Error
                abort = true;
                reject(err);
            } else {
                // other errors, such as incorrect content-encoding
                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
        body.on('data', function(chunk) {
            if (abort || chunk === null) {
                return;
            }
            if (_this4.size && accumBytes + chunk.length > _this4.size) {
                abort = true;
                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                return;
            }
            accumBytes += chunk.length;
            accum.push(chunk);
        });
        body.on('end', function() {
            if (abort) {
                return;
            }
            clearTimeout(resTimeout);
            try {
                resolve(Buffer.concat(accum, accumBytes));
            } catch (err) {
                // handle streams that have accumulated too much data (issue #414)
                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
    });
}
/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */ function convertBody(buffer, headers) {
    if (typeof convert !== 'function') {
        throw new Error('The package `encoding` must be installed to use the textConverted() function');
    }
    const ct = headers.get('content-type');
    let charset = 'utf-8';
    let res, str;
    // header
    if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
    }
    // no charset in content type, peek at response body for at most 1024 bytes
    str = buffer.slice(0, 1024).toString();
    // html5
    if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    // html4
    if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
            res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
            if (res) {
                res.pop(); // drop last quote
            }
        }
        if (res) {
            res = /charset=(.*)/i.exec(res.pop());
        }
    }
    // xml
    if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    // found charset
    if (res) {
        charset = res.pop();
        // prevent decode issues when sites use incorrect encoding
        // ref: https://hsivonen.fi/encoding-menu/
        if (charset === 'gb2312' || charset === 'gbk') {
            charset = 'gb18030';
        }
    }
    // turn raw buffers into a single utf-8 buffer
    return convert(buffer, 'UTF-8', charset).toString();
}
/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */ function isURLSearchParams(obj) {
    // Duck-typing as a necessary condition.
    if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
        return false;
    }
    // Brand-checking and more duck-typing as optional condition.
    return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}
/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */ function isBlob(obj) {
    return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */ function clone(instance) {
    let p1, p2;
    let body = instance.body;
    // don't allow cloning a used body
    if (instance.bodyUsed) {
        throw new Error('cannot clone body after it is used');
    }
    // check that body is a stream and not form-data object
    // note: we can't clone the form-data object without having it as a dependency
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"] && typeof body.getBoundary !== 'function') {
        // tee instance body
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        // set instance body to teed body and return the other teed body
        instance[INTERNALS].body = p1;
        body = p2;
    }
    return body;
}
/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */ function extractContentType(body) {
    if (body === null) {
        // body is null
        return null;
    } else if (typeof body === 'string') {
        // body is string
        return 'text/plain;charset=UTF-8';
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        return 'application/x-www-form-urlencoded;charset=UTF-8';
    } else if (isBlob(body)) {
        // body is blob
        return body.type || null;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return null;
    } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        return null;
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        return null;
    } else if (typeof body.getBoundary === 'function') {
        // detect form data input from form-data module
        return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        // body is stream
        // can't really do much about this
        return null;
    } else {
        // Body constructor defaults other things to string
        return 'text/plain;charset=UTF-8';
    }
}
/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */ function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        return 0;
    } else if (isBlob(body)) {
        return body.size;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return body.length;
    } else if (body && typeof body.getLengthSync === 'function') {
        // detect form data input from form-data module
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
            // 2.x
            return body.getLengthSync();
        }
        return null;
    } else {
        // body is stream
        return null;
    }
}
/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */ function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        dest.end();
    } else if (isBlob(body)) {
        body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        dest.write(body);
        dest.end();
    } else {
        // body is stream
        body.pipe(dest);
    }
}
// expose Promise
Body.Promise = /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */ const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === '') {
        throw new TypeError(`${name} is not a legal HTTP header name`);
    }
}
function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
    }
}
/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */ function find(map, name) {
    name = name.toLowerCase();
    for(const key in map){
        if (key.toLowerCase() === name) {
            return key;
        }
    }
    return undefined;
}
const MAP = Symbol('map');
class Headers {
    /**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */ constructor(){
        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
        this[MAP] = Object.create(null);
        if (init instanceof Headers) {
            const rawHeaders = init.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames){
                for (const value of rawHeaders[headerName]){
                    this.append(headerName, value);
                }
            }
            return;
        }
        // We don't worry about converting prop to ByteString here as append()
        // will handle it.
        if (init == null) ;
        else if (typeof init === 'object') {
            const method = init[Symbol.iterator];
            if (method != null) {
                if (typeof method !== 'function') {
                    throw new TypeError('Header pairs must be iterable');
                }
                // sequence<sequence<ByteString>>
                // Note: per spec we have to first exhaust the lists then process them
                const pairs = [];
                for (const pair of init){
                    if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
                        throw new TypeError('Each header pair must be iterable');
                    }
                    pairs.push(Array.from(pair));
                }
                for (const pair of pairs){
                    if (pair.length !== 2) {
                        throw new TypeError('Each header pair must be a name/value tuple');
                    }
                    this.append(pair[0], pair[1]);
                }
            } else {
                // record<ByteString, ByteString>
                for (const key of Object.keys(init)){
                    const value = init[key];
                    this.append(key, value);
                }
            }
        } else {
            throw new TypeError('Provided initializer must be an object');
        }
    }
    /**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */ get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === undefined) {
            return null;
        }
        return this[MAP][key].join(', ');
    }
    /**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */ forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        let pairs = getHeaders(this);
        let i = 0;
        while(i < pairs.length){
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
        }
    }
    /**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== undefined ? key : name] = [
            value
        ];
    }
    /**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            this[MAP][key].push(value);
        } else {
            this[MAP][name] = [
                value
            ];
        }
    }
    /**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */ has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== undefined;
    }
    /**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */ delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            delete this[MAP][key];
        }
    }
    /**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */ raw() {
        return this[MAP];
    }
    /**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */ keys() {
        return createHeadersIterator(this, 'key');
    }
    /**
  * Get an iterator on values.
  *
  * @return  Iterator
  */ values() {
        return createHeadersIterator(this, 'value');
    }
    /**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */ [Symbol.iterator]() {
        return createHeadersIterator(this, 'key+value');
    }
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: 'Headers',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Headers.prototype, {
    get: {
        enumerable: true
    },
    forEach: {
        enumerable: true
    },
    set: {
        enumerable: true
    },
    append: {
        enumerable: true
    },
    has: {
        enumerable: true
    },
    delete: {
        enumerable: true
    },
    keys: {
        enumerable: true
    },
    values: {
        enumerable: true
    },
    entries: {
        enumerable: true
    }
});
function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === 'key' ? function(k) {
        return k.toLowerCase();
    } : kind === 'value' ? function(k) {
        return headers[MAP][k].join(', ');
    } : function(k) {
        return [
            k.toLowerCase(),
            headers[MAP][k].join(', ')
        ];
    });
}
const INTERNAL = Symbol('internal');
function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
        target,
        kind,
        index: 0
    };
    return iterator;
}
const HeadersIteratorPrototype = Object.setPrototypeOf({
    next () {
        // istanbul ignore if
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError('Value of `this` is not a HeadersIterator');
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
            return {
                value: undefined,
                done: true
            };
        }
        this[INTERNAL].index = index + 1;
        return {
            value: values[index],
            done: false
        };
    }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: 'HeadersIterator',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */ function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({
        __proto__: null
    }, headers[MAP]);
    // http.request() only supports string as Host header. This hack makes
    // specifying custom Host header possible.
    const hostHeaderKey = find(headers[MAP], 'Host');
    if (hostHeaderKey !== undefined) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
}
/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */ function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)){
        if (invalidTokenRegex.test(name)) {
            continue;
        }
        if (Array.isArray(obj[name])) {
            for (const val of obj[name]){
                if (invalidHeaderCharRegex.test(val)) {
                    continue;
                }
                if (headers[MAP][name] === undefined) {
                    headers[MAP][name] = [
                        val
                    ];
                } else {
                    headers[MAP][name].push(val);
                }
            }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
            headers[MAP][name] = [
                obj[name]
            ];
        }
    }
    return headers;
}
const INTERNALS$1 = Symbol('Response internals');
// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"].STATUS_CODES;
/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ class Response {
    constructor(){
        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(body);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        this[INTERNALS$1] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter
        };
    }
    get url() {
        return this[INTERNALS$1].url || '';
    }
    get status() {
        return this[INTERNALS$1].status;
    }
    /**
  * Convenience property representing if the request ended normally
  */ get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
        return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
        return this[INTERNALS$1].statusText;
    }
    get headers() {
        return this[INTERNALS$1].headers;
    }
    /**
  * Clone this response
  *
  * @return  Response
  */ clone() {
        return new Response(clone(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
        });
    }
}
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
    url: {
        enumerable: true
    },
    status: {
        enumerable: true
    },
    ok: {
        enumerable: true
    },
    redirected: {
        enumerable: true
    },
    statusText: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    clone: {
        enumerable: true
    }
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: 'Response',
    writable: false,
    enumerable: false,
    configurable: true
});
const INTERNALS$2 = Symbol('Request internals');
const URL = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].parse;
const format_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].format;
/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */ function parseURL(urlStr) {
    /*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */ if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
    }
    // Fallback to old implementation for arbitrary URLs
    return parse_url(urlStr);
}
const streamDestructionSupported = 'destroy' in __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable.prototype;
/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */ function isRequest(input) {
    return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}
function isAbortSignal(signal) {
    const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === 'AbortSignal');
}
/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */ class Request {
    constructor(input){
        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let parsedURL;
        // normalize input
        if (!isRequest(input)) {
            if (input && input.href) {
                // in order to support Node.js' Url objects; though WHATWG's URL objects
                // will fall into this branch also (since their `toString()` will return
                // `href` property anyway)
                parsedURL = parseURL(input.href);
            } else {
                // coerce input to a string before attempting to parse
                parsedURL = parseURL(`${input}`);
            }
            input = {};
        } else {
            parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || 'GET';
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
            throw new TypeError('Request with GET/HEAD method cannot have body');
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ('signal' in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError('Expected signal to be an instanceof AbortSignal');
        }
        this[INTERNALS$2] = {
            method,
            redirect: init.redirect || input.redirect || 'follow',
            headers,
            parsedURL,
            signal
        };
        // node-fetch-only options
        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
    }
    get method() {
        return this[INTERNALS$2].method;
    }
    get url() {
        return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
        return this[INTERNALS$2].headers;
    }
    get redirect() {
        return this[INTERNALS$2].redirect;
    }
    get signal() {
        return this[INTERNALS$2].signal;
    }
    /**
  * Clone this request
  *
  * @return  Request
  */ clone() {
        return new Request(this);
    }
}
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: 'Request',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Request.prototype, {
    method: {
        enumerable: true
    },
    url: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    redirect: {
        enumerable: true
    },
    clone: {
        enumerable: true
    },
    signal: {
        enumerable: true
    }
});
/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */ function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    // fetch step 1.3
    if (!headers.has('Accept')) {
        headers.set('Accept', '*/*');
    }
    // Basic fetch
    if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError('Only absolute URLs are supported');
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError('Only HTTP(S) protocols are supported');
    }
    if (request.signal && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable && !streamDestructionSupported) {
        throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
    }
    // HTTP-network-or-cache fetch steps 2.4-2.7
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = '0';
    }
    if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === 'number') {
            contentLengthValue = String(totalBytes);
        }
    }
    if (contentLengthValue) {
        headers.set('Content-Length', contentLengthValue);
    }
    // HTTP-network-or-cache fetch step 2.11
    if (!headers.has('User-Agent')) {
        headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
    }
    // HTTP-network-or-cache fetch step 2.15
    if (request.compress && !headers.has('Accept-Encoding')) {
        headers.set('Accept-Encoding', 'gzip,deflate');
    }
    let agent = request.agent;
    if (typeof agent === 'function') {
        agent = agent(parsedURL);
    }
    // HTTP-network fetch step 4.2
    // chunked encoding is handled by Node.js
    return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
    });
}
/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */ /**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */ function AbortError(message) {
    Error.call(this, message);
    this.type = 'aborted';
    this.message = message;
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';
const URL$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};
/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */ const isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
};
/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */ function fetch(url, opts) {
    // allow custom promise
    if (!fetch.Promise) {
        throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
    }
    Body.Promise = fetch.Promise;
    // wrap http.request into fetch
    return new fetch.Promise(function(resolve, reject) {
        // build request object
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === 'https:' ? __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__["default"] : __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"]).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort() {
            let error = new AbortError('The user aborted a request.');
            reject(error);
            if (request.body && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable) {
                destroyStream(request.body, error);
            }
            if (!response || !response.body) return;
            response.body.emit('error', error);
        };
        if (signal && signal.aborted) {
            abort();
            return;
        }
        const abortAndFinalize = function abortAndFinalize() {
            abort();
            finalize();
        };
        // send request
        const req = send(options);
        let reqTimeout;
        if (signal) {
            signal.addEventListener('abort', abortAndFinalize);
        }
        function finalize() {
            req.abort();
            if (signal) signal.removeEventListener('abort', abortAndFinalize);
            clearTimeout(reqTimeout);
        }
        if (request.timeout) {
            req.once('socket', function(socket) {
                reqTimeout = setTimeout(function() {
                    reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                    finalize();
                }, request.timeout);
            });
        }
        req.on('error', function(err) {
            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
            if (response && response.body) {
                destroyStream(response.body, err);
            }
            finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
            if (signal && signal.aborted) {
                return;
            }
            if (response && response.body) {
                destroyStream(response.body, err);
            }
        });
        /* c8 ignore next 18 */ if (parseInt(process.version.substring(1)) < 14) {
            // Before Node.js 14, pipeline() does not fully support async iterators and does not always
            // properly handle when the socket close/end events are out of order.
            req.on('socket', function(s) {
                s.addListener('close', function(hadError) {
                    // if a data listener is still present we didn't end cleanly
                    const hasDataListener = s.listenerCount('data') > 0;
                    // if end happened before close but the socket didn't emit an error, do it now
                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                        const err = new Error('Premature close');
                        err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        response.body.emit('error', err);
                    }
                });
            });
        }
        req.on('response', function(res) {
            clearTimeout(reqTimeout);
            const headers = createHeadersLenient(res.headers);
            // HTTP fetch step 5
            if (fetch.isRedirect(res.statusCode)) {
                // HTTP fetch step 5.2
                const location = headers.get('Location');
                // HTTP fetch step 5.3
                let locationURL = null;
                try {
                    locationURL = location === null ? null : new URL$1(location, request.url).toString();
                } catch (err) {
                    // error here can only be invalid URL in Location: header
                    // do not throw when options.redirect == manual
                    // let the user extract the errorneous redirect URL
                    if (request.redirect !== 'manual') {
                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                        finalize();
                        return;
                    }
                }
                // HTTP fetch step 5.5
                switch(request.redirect){
                    case 'error':
                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                        finalize();
                        return;
                    case 'manual':
                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                        if (locationURL !== null) {
                            // handle corrupted header
                            try {
                                headers.set('Location', locationURL);
                            } catch (err) {
                                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                reject(err);
                            }
                        }
                        break;
                    case 'follow':
                        // HTTP-redirect fetch step 2
                        if (locationURL === null) {
                            break;
                        }
                        // HTTP-redirect fetch step 5
                        if (request.counter >= request.follow) {
                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 6 (counter increment)
                        // Create a new Request object.
                        const requestOpts = {
                            headers: new Headers(request.headers),
                            follow: request.follow,
                            counter: request.counter + 1,
                            agent: request.agent,
                            compress: request.compress,
                            method: request.method,
                            body: request.body,
                            signal: request.signal,
                            timeout: request.timeout,
                            size: request.size
                        };
                        if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                            for (const name of [
                                'authorization',
                                'www-authenticate',
                                'cookie',
                                'cookie2'
                            ]){
                                requestOpts.headers.delete(name);
                            }
                        }
                        // HTTP-redirect fetch step 9
                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                            reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 11
                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
                            requestOpts.method = 'GET';
                            requestOpts.body = undefined;
                            requestOpts.headers.delete('content-length');
                        }
                        // HTTP-redirect fetch step 15
                        resolve(fetch(new Request(locationURL, requestOpts)));
                        finalize();
                        return;
                }
            }
            // prepare response
            res.once('end', function() {
                if (signal) signal.removeEventListener('abort', abortAndFinalize);
            });
            let body = res.pipe(new PassThrough$1());
            const response_options = {
                url: request.url,
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: headers,
                size: request.size,
                timeout: request.timeout,
                counter: request.counter
            };
            // HTTP-network fetch step 12.1.1.3
            const codings = headers.get('Content-Encoding');
            // HTTP-network fetch step 12.1.1.4: handle content codings
            // in following scenarios we ignore compression support
            // 1. compression support is disabled
            // 2. HEAD request
            // 3. no Content-Encoding header
            // 4. no content response (204)
            // 5. content not modified response (304)
            if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // For Node v6+
            // Be less strict when decoding compressed responses, since sometimes
            // servers send slightly invalid responses that are still accepted
            // by common browsers.
            // Always using Z_SYNC_FLUSH is what cURL does.
            const zlibOptions = {
                flush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH,
                finishFlush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH
            };
            // for gzip
            if (codings == 'gzip' || codings == 'x-gzip') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createGunzip(zlibOptions));
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // for deflate
            if (codings == 'deflate' || codings == 'x-deflate') {
                // handle the infamous raw deflate response from old servers
                // a hack for old IIS and Apache servers
                const raw = res.pipe(new PassThrough$1());
                raw.once('data', function(chunk) {
                    // see http://stackoverflow.com/questions/37519828
                    if ((chunk[0] & 0x0F) === 0x08) {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflate());
                    } else {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflateRaw());
                    }
                    response = new Response(body, response_options);
                    resolve(response);
                });
                raw.on('end', function() {
                    // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.
                    if (!response) {
                        response = new Response(body, response_options);
                        resolve(response);
                    }
                });
                return;
            }
            // for br
            if (codings == 'br' && typeof __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress === 'function') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress());
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // otherwise, use response as-is
            response = new Response(body, response_options);
            resolve(response);
        });
        writeToStream(req, request);
    });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on('socket', function(s) {
        socket = s;
    });
    request.on('response', function(response) {
        const headers = response.headers;
        if (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {
            response.once('close', function(hadError) {
                // tests for socket presence, as in some situations the
                // the 'socket' event is not triggered for the request
                // (happens in deno), avoids `TypeError`
                // if a data listener is still present we didn't end cleanly
                const hasDataListener = socket && socket.listenerCount('data') > 0;
                if (hasDataListener && !hadError) {
                    const err = new Error('Premature close');
                    err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                    errorCallback(err);
                }
            });
        }
    });
}
function destroyStream(stream, err) {
    if (stream.destroy) {
        stream.destroy(err);
    } else {
        // node < 8
        stream.emit('error', err);
        stream.end();
    }
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */ fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};
// expose Promise
fetch.Promise = /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
const __TURBOPACK__default__export__ = fetch;
;
}),
"[project]/node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbortError",
    ()=>AbortError,
    "FetchError",
    ()=>FetchError,
    "Headers",
    ()=>Headers,
    "Request",
    ()=>Request,
    "Response",
    ()=>Response,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/http [external] (http, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/https [external] (https, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/zlib [external] (zlib, cjs)");
;
;
;
;
;
;
// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js
// fix for "Readable" isn't a named export issue
const Readable = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable;
const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');
class Blob {
    constructor(){
        this[TYPE] = '';
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for(let i = 0; i < length; i++){
                const element = a[i];
                let buffer;
                if (element instanceof Buffer) {
                    buffer = element;
                } else if (ArrayBuffer.isView(element)) {
                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                } else if (element instanceof ArrayBuffer) {
                    buffer = Buffer.from(element);
                } else if (element instanceof Blob) {
                    buffer = element[BUFFER];
                } else {
                    buffer = Buffer.from(typeof element === 'string' ? element : String(element));
                }
                size += buffer.length;
                buffers.push(buffer);
            }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== undefined && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
            this[TYPE] = type;
        }
    }
    get size() {
        return this[BUFFER].length;
    }
    get type() {
        return this[TYPE];
    }
    text() {
        return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
    }
    stream() {
        const readable = new Readable();
        readable._read = function() {};
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
    }
    toString() {
        return '[object Blob]';
    }
    slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === undefined) {
            relativeStart = 0;
        } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
        } else {
            relativeStart = Math.min(start, size);
        }
        if (end === undefined) {
            relativeEnd = size;
        } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
        } else {
            relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], {
            type: arguments[2]
        });
        blob[BUFFER] = slicedBuffer;
        return blob;
    }
}
Object.defineProperties(Blob.prototype, {
    size: {
        enumerable: true
    },
    type: {
        enumerable: true
    },
    slice: {
        enumerable: true
    }
});
Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: 'Blob',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */ /**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */ function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    // when err.type is `system`, err.code contains system error code
    if (systemError) {
        this.code = this.errno = systemError.code;
    }
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';
let convert;
try {
    convert = (()=>{
        const e = new Error("Cannot find module 'encoding'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })().convert;
} catch (e) {}
const INTERNALS = Symbol('Body internals');
// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === undefined ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
    if (body == null) {
        // body is undefined or null
        body = null;
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        body = Buffer.from(body.toString());
    } else if (isBlob(body)) ;
    else if (Buffer.isBuffer(body)) ;
    else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) ;
    else {
        // none of the above
        // coerce to string then buffer
        body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        body.on('error', function(err) {
            const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
            _this[INTERNALS].error = error;
        });
    }
}
Body.prototype = {
    get body () {
        return this[INTERNALS].body;
    },
    get bodyUsed () {
        return this[INTERNALS].disturbed;
    },
    /**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */ arrayBuffer () {
        return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
    },
    /**
  * Return raw response as Blob
  *
  * @return Promise
  */ blob () {
        let ct = this.headers && this.headers.get('content-type') || '';
        return consumeBody.call(this).then(function(buf) {
            return Object.assign(// Prevent copying
            new Blob([], {
                type: ct.toLowerCase()
            }), {
                [BUFFER]: buf
            });
        });
    },
    /**
  * Decode response as json
  *
  * @return  Promise
  */ json () {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
            try {
                return JSON.parse(buffer.toString());
            } catch (err) {
                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
            }
        });
    },
    /**
  * Decode response as text
  *
  * @return  Promise
  */ text () {
        return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
        });
    },
    /**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */ buffer () {
        return consumeBody.call(this);
    },
    /**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */ textConverted () {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
        });
    }
};
// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
    body: {
        enumerable: true
    },
    bodyUsed: {
        enumerable: true
    },
    arrayBuffer: {
        enumerable: true
    },
    blob: {
        enumerable: true
    },
    json: {
        enumerable: true
    },
    text: {
        enumerable: true
    }
});
Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)){
        // istanbul ignore else: future proof
        if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
        }
    }
};
/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */ function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    // body is null
    if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is blob
    if (isBlob(body)) {
        body = body.stream();
    }
    // body is buffer
    if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
    }
    // istanbul ignore if: should never happen
    if (!(body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"])) {
        return Body.Promise.resolve(Buffer.alloc(0));
    }
    // body is stream
    // get ready to actually consume the body
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        // allow timeout on slow response body
        if (_this4.timeout) {
            resTimeout = setTimeout(function() {
                abort = true;
                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
            }, _this4.timeout);
        }
        // handle stream errors
        body.on('error', function(err) {
            if (err.name === 'AbortError') {
                // if the request was aborted, reject with this Error
                abort = true;
                reject(err);
            } else {
                // other errors, such as incorrect content-encoding
                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
        body.on('data', function(chunk) {
            if (abort || chunk === null) {
                return;
            }
            if (_this4.size && accumBytes + chunk.length > _this4.size) {
                abort = true;
                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                return;
            }
            accumBytes += chunk.length;
            accum.push(chunk);
        });
        body.on('end', function() {
            if (abort) {
                return;
            }
            clearTimeout(resTimeout);
            try {
                resolve(Buffer.concat(accum, accumBytes));
            } catch (err) {
                // handle streams that have accumulated too much data (issue #414)
                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
            }
        });
    });
}
/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */ function convertBody(buffer, headers) {
    if (typeof convert !== 'function') {
        throw new Error('The package `encoding` must be installed to use the textConverted() function');
    }
    const ct = headers.get('content-type');
    let charset = 'utf-8';
    let res, str;
    // header
    if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
    }
    // no charset in content type, peek at response body for at most 1024 bytes
    str = buffer.slice(0, 1024).toString();
    // html5
    if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    // html4
    if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
            res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
            if (res) {
                res.pop(); // drop last quote
            }
        }
        if (res) {
            res = /charset=(.*)/i.exec(res.pop());
        }
    }
    // xml
    if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    // found charset
    if (res) {
        charset = res.pop();
        // prevent decode issues when sites use incorrect encoding
        // ref: https://hsivonen.fi/encoding-menu/
        if (charset === 'gb2312' || charset === 'gbk') {
            charset = 'gb18030';
        }
    }
    // turn raw buffers into a single utf-8 buffer
    return convert(buffer, 'UTF-8', charset).toString();
}
/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */ function isURLSearchParams(obj) {
    // Duck-typing as a necessary condition.
    if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
        return false;
    }
    // Brand-checking and more duck-typing as optional condition.
    return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}
/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */ function isBlob(obj) {
    return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */ function clone(instance) {
    let p1, p2;
    let body = instance.body;
    // don't allow cloning a used body
    if (instance.bodyUsed) {
        throw new Error('cannot clone body after it is used');
    }
    // check that body is a stream and not form-data object
    // note: we can't clone the form-data object without having it as a dependency
    if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"] && typeof body.getBoundary !== 'function') {
        // tee instance body
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        // set instance body to teed body and return the other teed body
        instance[INTERNALS].body = p1;
        body = p2;
    }
    return body;
}
/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */ function extractContentType(body) {
    if (body === null) {
        // body is null
        return null;
    } else if (typeof body === 'string') {
        // body is string
        return 'text/plain;charset=UTF-8';
    } else if (isURLSearchParams(body)) {
        // body is a URLSearchParams
        return 'application/x-www-form-urlencoded;charset=UTF-8';
    } else if (isBlob(body)) {
        // body is blob
        return body.type || null;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return null;
    } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
        // body is ArrayBuffer
        return null;
    } else if (ArrayBuffer.isView(body)) {
        // body is ArrayBufferView
        return null;
    } else if (typeof body.getBoundary === 'function') {
        // detect form data input from form-data module
        return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"]) {
        // body is stream
        // can't really do much about this
        return null;
    } else {
        // Body constructor defaults other things to string
        return 'text/plain;charset=UTF-8';
    }
}
/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */ function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        return 0;
    } else if (isBlob(body)) {
        return body.size;
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        return body.length;
    } else if (body && typeof body.getLengthSync === 'function') {
        // detect form data input from form-data module
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
            // 2.x
            return body.getLengthSync();
        }
        return null;
    } else {
        // body is stream
        return null;
    }
}
/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */ function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
        // body is null
        dest.end();
    } else if (isBlob(body)) {
        body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
        // body is buffer
        dest.write(body);
        dest.end();
    } else {
        // body is stream
        body.pipe(dest);
    }
}
// expose Promise
Body.Promise = /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */ const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === '') {
        throw new TypeError(`${name} is not a legal HTTP header name`);
    }
}
function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
    }
}
/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */ function find(map, name) {
    name = name.toLowerCase();
    for(const key in map){
        if (key.toLowerCase() === name) {
            return key;
        }
    }
    return undefined;
}
const MAP = Symbol('map');
class Headers {
    /**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */ constructor(){
        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
        this[MAP] = Object.create(null);
        if (init instanceof Headers) {
            const rawHeaders = init.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames){
                for (const value of rawHeaders[headerName]){
                    this.append(headerName, value);
                }
            }
            return;
        }
        // We don't worry about converting prop to ByteString here as append()
        // will handle it.
        if (init == null) ;
        else if (typeof init === 'object') {
            const method = init[Symbol.iterator];
            if (method != null) {
                if (typeof method !== 'function') {
                    throw new TypeError('Header pairs must be iterable');
                }
                // sequence<sequence<ByteString>>
                // Note: per spec we have to first exhaust the lists then process them
                const pairs = [];
                for (const pair of init){
                    if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
                        throw new TypeError('Each header pair must be iterable');
                    }
                    pairs.push(Array.from(pair));
                }
                for (const pair of pairs){
                    if (pair.length !== 2) {
                        throw new TypeError('Each header pair must be a name/value tuple');
                    }
                    this.append(pair[0], pair[1]);
                }
            } else {
                // record<ByteString, ByteString>
                for (const key of Object.keys(init)){
                    const value = init[key];
                    this.append(key, value);
                }
            }
        } else {
            throw new TypeError('Provided initializer must be an object');
        }
    }
    /**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */ get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === undefined) {
            return null;
        }
        return this[MAP][key].join(', ');
    }
    /**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */ forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        let pairs = getHeaders(this);
        let i = 0;
        while(i < pairs.length){
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
        }
    }
    /**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== undefined ? key : name] = [
            value
        ];
    }
    /**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */ append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            this[MAP][key].push(value);
        } else {
            this[MAP][name] = [
                value
            ];
        }
    }
    /**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */ has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== undefined;
    }
    /**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */ delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== undefined) {
            delete this[MAP][key];
        }
    }
    /**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */ raw() {
        return this[MAP];
    }
    /**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */ keys() {
        return createHeadersIterator(this, 'key');
    }
    /**
  * Get an iterator on values.
  *
  * @return  Iterator
  */ values() {
        return createHeadersIterator(this, 'value');
    }
    /**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */ [Symbol.iterator]() {
        return createHeadersIterator(this, 'key+value');
    }
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: 'Headers',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Headers.prototype, {
    get: {
        enumerable: true
    },
    forEach: {
        enumerable: true
    },
    set: {
        enumerable: true
    },
    append: {
        enumerable: true
    },
    has: {
        enumerable: true
    },
    delete: {
        enumerable: true
    },
    keys: {
        enumerable: true
    },
    values: {
        enumerable: true
    },
    entries: {
        enumerable: true
    }
});
function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === 'key' ? function(k) {
        return k.toLowerCase();
    } : kind === 'value' ? function(k) {
        return headers[MAP][k].join(', ');
    } : function(k) {
        return [
            k.toLowerCase(),
            headers[MAP][k].join(', ')
        ];
    });
}
const INTERNAL = Symbol('internal');
function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
        target,
        kind,
        index: 0
    };
    return iterator;
}
const HeadersIteratorPrototype = Object.setPrototypeOf({
    next () {
        // istanbul ignore if
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError('Value of `this` is not a HeadersIterator');
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
            return {
                value: undefined,
                done: true
            };
        }
        this[INTERNAL].index = index + 1;
        return {
            value: values[index],
            done: false
        };
    }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: 'HeadersIterator',
    writable: false,
    enumerable: false,
    configurable: true
});
/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */ function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({
        __proto__: null
    }, headers[MAP]);
    // http.request() only supports string as Host header. This hack makes
    // specifying custom Host header possible.
    const hostHeaderKey = find(headers[MAP], 'Host');
    if (hostHeaderKey !== undefined) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
}
/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */ function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)){
        if (invalidTokenRegex.test(name)) {
            continue;
        }
        if (Array.isArray(obj[name])) {
            for (const val of obj[name]){
                if (invalidHeaderCharRegex.test(val)) {
                    continue;
                }
                if (headers[MAP][name] === undefined) {
                    headers[MAP][name] = [
                        val
                    ];
                } else {
                    headers[MAP][name].push(val);
                }
            }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
            headers[MAP][name] = [
                obj[name]
            ];
        }
    }
    return headers;
}
const INTERNALS$1 = Symbol('Response internals');
// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"].STATUS_CODES;
/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */ class Response {
    constructor(){
        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(body);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        this[INTERNALS$1] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter
        };
    }
    get url() {
        return this[INTERNALS$1].url || '';
    }
    get status() {
        return this[INTERNALS$1].status;
    }
    /**
  * Convenience property representing if the request ended normally
  */ get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
        return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
        return this[INTERNALS$1].statusText;
    }
    get headers() {
        return this[INTERNALS$1].headers;
    }
    /**
  * Clone this response
  *
  * @return  Response
  */ clone() {
        return new Response(clone(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
        });
    }
}
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
    url: {
        enumerable: true
    },
    status: {
        enumerable: true
    },
    ok: {
        enumerable: true
    },
    redirected: {
        enumerable: true
    },
    statusText: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    clone: {
        enumerable: true
    }
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: 'Response',
    writable: false,
    enumerable: false,
    configurable: true
});
const INTERNALS$2 = Symbol('Request internals');
const URL = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].parse;
const format_url = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].format;
/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */ function parseURL(urlStr) {
    /*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */ if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
    }
    // Fallback to old implementation for arbitrary URLs
    return parse_url(urlStr);
}
const streamDestructionSupported = 'destroy' in __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable.prototype;
/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */ function isRequest(input) {
    return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}
function isAbortSignal(signal) {
    const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === 'AbortSignal');
}
/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */ class Request {
    constructor(input){
        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let parsedURL;
        // normalize input
        if (!isRequest(input)) {
            if (input && input.href) {
                // in order to support Node.js' Url objects; though WHATWG's URL objects
                // will fall into this branch also (since their `toString()` will return
                // `href` property anyway)
                parsedURL = parseURL(input.href);
            } else {
                // coerce input to a string before attempting to parse
                parsedURL = parseURL(`${input}`);
            }
            input = {};
        } else {
            parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || 'GET';
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
            throw new TypeError('Request with GET/HEAD method cannot have body');
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has('Content-Type')) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
                headers.append('Content-Type', contentType);
            }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ('signal' in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError('Expected signal to be an instanceof AbortSignal');
        }
        this[INTERNALS$2] = {
            method,
            redirect: init.redirect || input.redirect || 'follow',
            headers,
            parsedURL,
            signal
        };
        // node-fetch-only options
        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
    }
    get method() {
        return this[INTERNALS$2].method;
    }
    get url() {
        return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
        return this[INTERNALS$2].headers;
    }
    get redirect() {
        return this[INTERNALS$2].redirect;
    }
    get signal() {
        return this[INTERNALS$2].signal;
    }
    /**
  * Clone this request
  *
  * @return  Request
  */ clone() {
        return new Request(this);
    }
}
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: 'Request',
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperties(Request.prototype, {
    method: {
        enumerable: true
    },
    url: {
        enumerable: true
    },
    headers: {
        enumerable: true
    },
    redirect: {
        enumerable: true
    },
    clone: {
        enumerable: true
    },
    signal: {
        enumerable: true
    }
});
/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */ function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    // fetch step 1.3
    if (!headers.has('Accept')) {
        headers.set('Accept', '*/*');
    }
    // Basic fetch
    if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError('Only absolute URLs are supported');
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError('Only HTTP(S) protocols are supported');
    }
    if (request.signal && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable && !streamDestructionSupported) {
        throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
    }
    // HTTP-network-or-cache fetch steps 2.4-2.7
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = '0';
    }
    if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === 'number') {
            contentLengthValue = String(totalBytes);
        }
    }
    if (contentLengthValue) {
        headers.set('Content-Length', contentLengthValue);
    }
    // HTTP-network-or-cache fetch step 2.11
    if (!headers.has('User-Agent')) {
        headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
    }
    // HTTP-network-or-cache fetch step 2.15
    if (request.compress && !headers.has('Accept-Encoding')) {
        headers.set('Accept-Encoding', 'gzip,deflate');
    }
    let agent = request.agent;
    if (typeof agent === 'function') {
        agent = agent(parsedURL);
    }
    // HTTP-network fetch step 4.2
    // chunked encoding is handled by Node.js
    return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
    });
}
/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */ /**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */ function AbortError(message) {
    Error.call(this, message);
    this.type = 'aborted';
    this.message = message;
    // hide custom error implementation details from end-users
    Error.captureStackTrace(this, this.constructor);
}
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';
const URL$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["default"].URL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$whatwg$2d$url$40$5$2e$0$2e$0$2f$node_modules$2f$whatwg$2d$url$2f$lib$2f$public$2d$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].URL;
// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].PassThrough;
const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
    const orig = new URL$1(original).hostname;
    const dest = new URL$1(destination).hostname;
    return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};
/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */ const isSameProtocol = function isSameProtocol(destination, original) {
    const orig = new URL$1(original).protocol;
    const dest = new URL$1(destination).protocol;
    return orig === dest;
};
/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */ function fetch(url, opts) {
    // allow custom promise
    if (!fetch.Promise) {
        throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
    }
    Body.Promise = fetch.Promise;
    // wrap http.request into fetch
    return new fetch.Promise(function(resolve, reject) {
        // build request object
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === 'https:' ? __TURBOPACK__imported__module__$5b$externals$5d2f$https__$5b$external$5d$__$28$https$2c$__cjs$29$__["default"] : __TURBOPACK__imported__module__$5b$externals$5d2f$http__$5b$external$5d$__$28$http$2c$__cjs$29$__["default"]).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort() {
            let error = new AbortError('The user aborted a request.');
            reject(error);
            if (request.body && request.body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["default"].Readable) {
                destroyStream(request.body, error);
            }
            if (!response || !response.body) return;
            response.body.emit('error', error);
        };
        if (signal && signal.aborted) {
            abort();
            return;
        }
        const abortAndFinalize = function abortAndFinalize() {
            abort();
            finalize();
        };
        // send request
        const req = send(options);
        let reqTimeout;
        if (signal) {
            signal.addEventListener('abort', abortAndFinalize);
        }
        function finalize() {
            req.abort();
            if (signal) signal.removeEventListener('abort', abortAndFinalize);
            clearTimeout(reqTimeout);
        }
        if (request.timeout) {
            req.once('socket', function(socket) {
                reqTimeout = setTimeout(function() {
                    reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                    finalize();
                }, request.timeout);
            });
        }
        req.on('error', function(err) {
            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
            if (response && response.body) {
                destroyStream(response.body, err);
            }
            finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
            if (signal && signal.aborted) {
                return;
            }
            if (response && response.body) {
                destroyStream(response.body, err);
            }
        });
        /* c8 ignore next 18 */ if (parseInt(process.version.substring(1)) < 14) {
            // Before Node.js 14, pipeline() does not fully support async iterators and does not always
            // properly handle when the socket close/end events are out of order.
            req.on('socket', function(s) {
                s.addListener('close', function(hadError) {
                    // if a data listener is still present we didn't end cleanly
                    const hasDataListener = s.listenerCount('data') > 0;
                    // if end happened before close but the socket didn't emit an error, do it now
                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                        const err = new Error('Premature close');
                        err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        response.body.emit('error', err);
                    }
                });
            });
        }
        req.on('response', function(res) {
            clearTimeout(reqTimeout);
            const headers = createHeadersLenient(res.headers);
            // HTTP fetch step 5
            if (fetch.isRedirect(res.statusCode)) {
                // HTTP fetch step 5.2
                const location = headers.get('Location');
                // HTTP fetch step 5.3
                let locationURL = null;
                try {
                    locationURL = location === null ? null : new URL$1(location, request.url).toString();
                } catch (err) {
                    // error here can only be invalid URL in Location: header
                    // do not throw when options.redirect == manual
                    // let the user extract the errorneous redirect URL
                    if (request.redirect !== 'manual') {
                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                        finalize();
                        return;
                    }
                }
                // HTTP fetch step 5.5
                switch(request.redirect){
                    case 'error':
                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                        finalize();
                        return;
                    case 'manual':
                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
                        if (locationURL !== null) {
                            // handle corrupted header
                            try {
                                headers.set('Location', locationURL);
                            } catch (err) {
                                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
                                reject(err);
                            }
                        }
                        break;
                    case 'follow':
                        // HTTP-redirect fetch step 2
                        if (locationURL === null) {
                            break;
                        }
                        // HTTP-redirect fetch step 5
                        if (request.counter >= request.follow) {
                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 6 (counter increment)
                        // Create a new Request object.
                        const requestOpts = {
                            headers: new Headers(request.headers),
                            follow: request.follow,
                            counter: request.counter + 1,
                            agent: request.agent,
                            compress: request.compress,
                            method: request.method,
                            body: request.body,
                            signal: request.signal,
                            timeout: request.timeout,
                            size: request.size
                        };
                        if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                            for (const name of [
                                'authorization',
                                'www-authenticate',
                                'cookie',
                                'cookie2'
                            ]){
                                requestOpts.headers.delete(name);
                            }
                        }
                        // HTTP-redirect fetch step 9
                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                            reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                            finalize();
                            return;
                        }
                        // HTTP-redirect fetch step 11
                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
                            requestOpts.method = 'GET';
                            requestOpts.body = undefined;
                            requestOpts.headers.delete('content-length');
                        }
                        // HTTP-redirect fetch step 15
                        resolve(fetch(new Request(locationURL, requestOpts)));
                        finalize();
                        return;
                }
            }
            // prepare response
            res.once('end', function() {
                if (signal) signal.removeEventListener('abort', abortAndFinalize);
            });
            let body = res.pipe(new PassThrough$1());
            const response_options = {
                url: request.url,
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: headers,
                size: request.size,
                timeout: request.timeout,
                counter: request.counter
            };
            // HTTP-network fetch step 12.1.1.3
            const codings = headers.get('Content-Encoding');
            // HTTP-network fetch step 12.1.1.4: handle content codings
            // in following scenarios we ignore compression support
            // 1. compression support is disabled
            // 2. HEAD request
            // 3. no Content-Encoding header
            // 4. no content response (204)
            // 5. content not modified response (304)
            if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // For Node v6+
            // Be less strict when decoding compressed responses, since sometimes
            // servers send slightly invalid responses that are still accepted
            // by common browsers.
            // Always using Z_SYNC_FLUSH is what cURL does.
            const zlibOptions = {
                flush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH,
                finishFlush: __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].Z_SYNC_FLUSH
            };
            // for gzip
            if (codings == 'gzip' || codings == 'x-gzip') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createGunzip(zlibOptions));
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // for deflate
            if (codings == 'deflate' || codings == 'x-deflate') {
                // handle the infamous raw deflate response from old servers
                // a hack for old IIS and Apache servers
                const raw = res.pipe(new PassThrough$1());
                raw.once('data', function(chunk) {
                    // see http://stackoverflow.com/questions/37519828
                    if ((chunk[0] & 0x0F) === 0x08) {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflate());
                    } else {
                        body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createInflateRaw());
                    }
                    response = new Response(body, response_options);
                    resolve(response);
                });
                raw.on('end', function() {
                    // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.
                    if (!response) {
                        response = new Response(body, response_options);
                        resolve(response);
                    }
                });
                return;
            }
            // for br
            if (codings == 'br' && typeof __TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress === 'function') {
                body = body.pipe(__TURBOPACK__imported__module__$5b$externals$5d2f$zlib__$5b$external$5d$__$28$zlib$2c$__cjs$29$__["default"].createBrotliDecompress());
                response = new Response(body, response_options);
                resolve(response);
                return;
            }
            // otherwise, use response as-is
            response = new Response(body, response_options);
            resolve(response);
        });
        writeToStream(req, request);
    });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on('socket', function(s) {
        socket = s;
    });
    request.on('response', function(response) {
        const headers = response.headers;
        if (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {
            response.once('close', function(hadError) {
                // tests for socket presence, as in some situations the
                // the 'socket' event is not triggered for the request
                // (happens in deno), avoids `TypeError`
                // if a data listener is still present we didn't end cleanly
                const hasDataListener = socket && socket.listenerCount('data') > 0;
                if (hasDataListener && !hadError) {
                    const err = new Error('Premature close');
                    err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                    errorCallback(err);
                }
            });
        }
    });
}
function destroyStream(stream, err) {
    if (stream.destroy) {
        stream.destroy(err);
    } else {
        // node < 8
        stream.emit('error', err);
        stream.end();
    }
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */ fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};
// expose Promise
fetch.Promise = /*TURBOPACK member replacement*/ __turbopack_context__.g.Promise;
const __TURBOPACK__default__export__ = fetch;
;
}),
"[project]/node_modules/.pnpm/fetch-ponyfill@7.1.0/node_modules/fetch-ponyfill/fetch-node.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fetch = __turbopack_context__.r("[project]/node_modules/.pnpm/node-fetch@2.6.13/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)");
function wrapFetchForNode(fetch) {
    // Support schemaless URIs on the server for parity with the browser.
    // https://github.com/matthew-andrews/isomorphic-fetch/pull/10
    return function(u, options) {
        if (typeof u === 'string' && u.slice(0, 2) === '//') {
            return fetch('https:' + u, options);
        }
        return fetch(u, options);
    };
}
module.exports = function(context) {
    // Support webpack module import weirdness.
    var fetchFn = fetch.default ? fetch.default : fetch;
    // This modifies the global `node-fetch` object, which isn't great, since
    // different callers to `fetch-ponyfill` which pass a different Promise
    // implementation would each expect to have their implementation used. But,
    // given the way `node-fetch` is implemented, this is the only way to make
    // it work at all.
    if (context && context.Promise) {
        fetchFn.Promise = context.Promise;
    }
    return {
        fetch: wrapFetchForNode(fetchFn),
        Headers: fetch.Headers,
        Request: fetch.Request,
        Response: fetch.Response
    };
};
}),
"[project]/node_modules/.pnpm/@nhost+hasura-auth-js@2.12.0/node_modules/@nhost/hasura-auth-js/dist/index.cjs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const er = __turbopack_context__.r("[project]/node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/cjs/index.js [app-ssr] (ecmascript)"), u = __turbopack_context__.r("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/index.js [app-ssr] (ecmascript)"), W = __turbopack_context__.r("[project]/node_modules/.pnpm/js-cookie@3.0.5/node_modules/js-cookie/dist/js.cookie.js [app-ssr] (ecmascript)"), rr = __turbopack_context__.r("[project]/node_modules/.pnpm/fetch-ponyfill@7.1.0/node_modules/fetch-ponyfill/fetch-node.js [app-ssr] (ecmascript)"), N = "nhostRefreshToken", D = "nhostRefreshTokenId", v = "nhostRefreshTokenExpiresAt", ie = 3, Y = 60, F = 5, J = 0, ee = 1, A = 10, b = 20;
class O extends Error {
    constructor(e){
        super(e.message), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), e instanceof Error ? (this.name = e.name, this.error = {
            error: e.name,
            status: ee,
            message: e.message
        }) : (this.name = e.error, this.error = e);
    }
}
const k = {
    status: A,
    error: "invalid-email",
    message: "Email is incorrectly formatted"
}, oe = {
    status: A,
    error: "invalid-mfa-type",
    message: "MFA type is invalid"
}, ae = {
    status: A,
    error: "invalid-mfa-code",
    message: "MFA code is invalid"
}, V = {
    status: A,
    error: "invalid-password",
    message: "Password is incorrectly formatted"
}, j = {
    status: A,
    error: "invalid-phone-number",
    message: "Phone number is incorrectly formatted"
}, ce = {
    status: A,
    error: "invalid-mfa-ticket",
    message: "MFA ticket is invalid"
}, le = {
    status: A,
    error: "no-mfa-ticket",
    message: "No MFA ticket has been provided"
}, ue = {
    status: A,
    error: "no-refresh-token",
    message: "No refresh token has been provided"
}, de = {
    status: b,
    error: "refresher-already-running",
    message: "The token refresher is already running. You must wait until is has finished before submitting a new token."
}, w = {
    status: b,
    error: "already-signed-in",
    message: "User is already signed in"
}, he = {
    status: b,
    error: "unauthenticated-user",
    message: "User is not authenticated"
}, sr = {
    status: b,
    error: "user-not-anonymous",
    message: "User is not anonymous"
}, fe = {
    status: b,
    error: "unverified-user",
    message: "Email needs verification"
}, Ee = {
    status: A,
    error: "invalid-refresh-token",
    message: "Invalid or expired refresh token"
}, me = {
    status: ee,
    error: "invalid-sign-in-method",
    message: "Invalid sign-in method"
}, U = {
    user: null,
    mfa: null,
    accessToken: {
        value: null,
        expiresAt: null,
        expiresInSeconds: 15
    },
    refreshTimer: {
        startedAt: null,
        attempts: 0,
        lastAttempt: null
    },
    refreshToken: {
        value: null
    },
    importTokenAttempts: 0,
    errors: {}
};
function nr(n) {
    return new TextEncoder().encode(n);
}
function P(n) {
    const e = new Uint8Array(n);
    let r = "";
    for (const t of e)r += String.fromCharCode(t);
    return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function re(n) {
    const e = n.replace(/-/g, "+").replace(/_/g, "/"), r = (4 - e.length % 4) % 4, s = e.padEnd(e.length + r, "="), t = atob(s), i = new ArrayBuffer(t.length), l = new Uint8Array(i);
    for(let f = 0; f < t.length; f++)l[f] = t.charCodeAt(f);
    return i;
}
function ge() {
    return (window == null ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential == "function";
}
function Te(n) {
    const { id: e } = n;
    return {
        ...n,
        id: re(e),
        transports: n.transports
    };
}
function pe(n) {
    return n === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n);
}
class p extends Error {
    constructor({ message: e, code: r, cause: s, name: t }){
        super(e, {
            cause: s
        }), this.name = t != null ? t : s.name, this.code = r;
    }
}
function tr({ error: n, options: e }) {
    var s, t;
    const { publicKey: r } = e;
    if (!r) throw Error("options was missing required publicKey property");
    if (n.name === "AbortError") {
        if (e.signal instanceof AbortSignal) return new p({
            message: "Registration ceremony was sent an abort signal",
            code: "ERROR_CEREMONY_ABORTED",
            cause: n
        });
    } else if (n.name === "ConstraintError") {
        if (((s = r.authenticatorSelection) == null ? void 0 : s.requireResidentKey) === !0) return new p({
            message: "Discoverable credentials were required but no available authenticator supported it",
            code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
            cause: n
        });
        if (((t = r.authenticatorSelection) == null ? void 0 : t.userVerification) === "required") return new p({
            message: "User verification was required but no available authenticator supported it",
            code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
            cause: n
        });
    } else {
        if (n.name === "InvalidStateError") return new p({
            message: "The authenticator was previously registered",
            code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
            cause: n
        });
        if (n.name === "NotAllowedError") return new p({
            message: n.message,
            code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
            cause: n
        });
        if (n.name === "NotSupportedError") return r.pubKeyCredParams.filter((l)=>l.type === "public-key").length === 0 ? new p({
            message: 'No entry in pubKeyCredParams was of type "public-key"',
            code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
            cause: n
        }) : new p({
            message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
            code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
            cause: n
        });
        if (n.name === "SecurityError") {
            const i = window.location.hostname;
            if (pe(i)) {
                if (r.rp.id !== i) return new p({
                    message: `The RP ID "${r.rp.id}" is invalid for this domain`,
                    code: "ERROR_INVALID_RP_ID",
                    cause: n
                });
            } else return new p({
                message: `${window.location.hostname} is an invalid domain`,
                code: "ERROR_INVALID_DOMAIN",
                cause: n
            });
        } else if (n.name === "TypeError") {
            if (r.user.id.byteLength < 1 || r.user.id.byteLength > 64) return new p({
                message: "User ID was not between 1 and 64 characters",
                code: "ERROR_INVALID_USER_ID_LENGTH",
                cause: n
            });
        } else if (n.name === "UnknownError") return new p({
            message: "The authenticator was unable to process the specified options, or could not create a new credential",
            code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
            cause: n
        });
    }
    return n;
}
class ir {
    createNewAbortSignal() {
        if (this.controller) {
            const r = new Error("Cancelling existing WebAuthn API call for new one");
            r.name = "AbortError", this.controller.abort(r);
        }
        const e = new AbortController;
        return this.controller = e, e.signal;
    }
    cancelCeremony() {
        if (this.controller) {
            const e = new Error("Manually cancelling existing WebAuthn API call");
            e.name = "AbortError", this.controller.abort(e), this.controller = void 0;
        }
    }
}
const we = new ir, or = [
    "cross-platform",
    "platform"
];
function Ie(n) {
    if (n && !(or.indexOf(n) < 0)) return n;
}
async function Se(n) {
    var a;
    if (!ge()) throw new Error("WebAuthn is not supported in this browser");
    const r = {
        publicKey: {
            ...n,
            challenge: re(n.challenge),
            user: {
                ...n.user,
                id: nr(n.user.id)
            },
            excludeCredentials: (a = n.excludeCredentials) == null ? void 0 : a.map(Te)
        }
    };
    r.signal = we.createNewAbortSignal();
    let s;
    try {
        s = await navigator.credentials.create(r);
    } catch (o) {
        throw tr({
            error: o,
            options: r
        });
    }
    if (!s) throw new Error("Registration was not completed");
    const { id: t, rawId: i, response: l, type: f } = s;
    let h;
    typeof l.getTransports == "function" && (h = l.getTransports());
    let E;
    if (typeof l.getPublicKeyAlgorithm == "function") try {
        E = l.getPublicKeyAlgorithm();
    } catch (o) {
        $("getPublicKeyAlgorithm()", o);
    }
    let g;
    if (typeof l.getPublicKey == "function") try {
        const o = l.getPublicKey();
        o !== null && (g = P(o));
    } catch (o) {
        $("getPublicKey()", o);
    }
    let T;
    if (typeof l.getAuthenticatorData == "function") try {
        T = P(l.getAuthenticatorData());
    } catch (o) {
        $("getAuthenticatorData()", o);
    }
    return {
        id: t,
        rawId: P(i),
        response: {
            attestationObject: P(l.attestationObject),
            clientDataJSON: P(l.clientDataJSON),
            transports: h,
            publicKeyAlgorithm: E,
            publicKey: g,
            authenticatorData: T
        },
        type: f,
        clientExtensionResults: s.getClientExtensionResults(),
        authenticatorAttachment: Ie(s.authenticatorAttachment)
    };
}
function $(n, e) {
    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${n}. You should report this error to them.
`, e);
}
function ar(n) {
    return new TextDecoder("utf-8").decode(n);
}
function cr() {
    const n = window.PublicKeyCredential;
    return n.isConditionalMediationAvailable === void 0 ? new Promise((e)=>e(!1)) : n.isConditionalMediationAvailable();
}
function lr({ error: n, options: e }) {
    const { publicKey: r } = e;
    if (!r) throw Error("options was missing required publicKey property");
    if (n.name === "AbortError") {
        if (e.signal instanceof AbortSignal) return new p({
            message: "Authentication ceremony was sent an abort signal",
            code: "ERROR_CEREMONY_ABORTED",
            cause: n
        });
    } else {
        if (n.name === "NotAllowedError") return new p({
            message: n.message,
            code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
            cause: n
        });
        if (n.name === "SecurityError") {
            const s = window.location.hostname;
            if (pe(s)) {
                if (r.rpId !== s) return new p({
                    message: `The RP ID "${r.rpId}" is invalid for this domain`,
                    code: "ERROR_INVALID_RP_ID",
                    cause: n
                });
            } else return new p({
                message: `${window.location.hostname} is an invalid domain`,
                code: "ERROR_INVALID_DOMAIN",
                cause: n
            });
        } else if (n.name === "UnknownError") return new p({
            message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
            code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
            cause: n
        });
    }
    return n;
}
async function q(n, e = !1) {
    var T, a;
    if (!ge()) throw new Error("WebAuthn is not supported in this browser");
    let r;
    ((T = n.allowCredentials) == null ? void 0 : T.length) !== 0 && (r = (a = n.allowCredentials) == null ? void 0 : a.map(Te));
    const s = {
        ...n,
        challenge: re(n.challenge),
        allowCredentials: r
    }, t = {};
    if (e) {
        if (!await cr()) throw Error("Browser does not support WebAuthn autofill");
        if (document.querySelectorAll("input[autocomplete$='webauthn']").length < 1) throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');
        t.mediation = "conditional", s.allowCredentials = [];
    }
    t.publicKey = s, t.signal = we.createNewAbortSignal();
    let i;
    try {
        i = await navigator.credentials.get(t);
    } catch (o) {
        throw lr({
            error: o,
            options: t
        });
    }
    if (!i) throw new Error("Authentication was not completed");
    const { id: l, rawId: f, response: h, type: E } = i;
    let g;
    return h.userHandle && (g = ar(h.userHandle)), {
        id: l,
        rawId: P(f),
        response: {
            authenticatorData: P(h.authenticatorData),
            clientDataJSON: P(h.clientDataJSON),
            signature: P(h.signature),
            userHandle: g
        },
        type: E,
        clientExtensionResults: i.getClientExtensionResults(),
        authenticatorAttachment: Ie(i.authenticatorAttachment)
    };
}
const H = ("TURBOPACK compile-time value", "undefined") != "undefined", K = new Map, ur = (n)=>{
    var e;
    return ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : (e = K.get(n)) != null ? e : null;
}, dr = (n, e)=>{
    ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : e ? K.set(n, e) : K.has(n) && K.delete(n);
}, Re = (n, e)=>{
    if (n === "localStorage" || n === "web") return ur;
    if (n === "cookie") return (r)=>{
        var s;
        return H && (s = W.get(r)) != null ? "TURBOPACK unreachable" : null;
    };
    if (!e) throw Error(`clientStorageType is set to '${n}' but no clientStorage has been given`);
    if (n === "react-native") return (r)=>{
        var s;
        return (s = e.getItem) == null ? void 0 : s.call(e, r);
    };
    if (n === "capacitor") return (r)=>{
        var s;
        return (s = e.get) == null ? void 0 : s.call(e, {
            key: r
        });
    };
    if (n === "expo-secure-storage") return (r)=>{
        var s;
        return (s = e.getItemAsync) == null ? void 0 : s.call(e, r);
    };
    if (n === "custom") {
        if (e.getItem && e.removeItem) return e.getItem;
        if (e.getItemAsync) return e.getItemAsync;
        throw Error(`clientStorageType is set to 'custom' but clientStorage is missing either "getItem" and "removeItem" properties or "getItemAsync" property`);
    }
    throw Error(`Unknown storage type: ${n}`);
}, _e = (n, e)=>{
    if (n === "localStorage" || n === "web") return dr;
    if (n === "cookie") return (r, s)=>{
        H && (s ? W.set(r, s, {
            expires: 30,
            sameSite: "lax",
            httpOnly: !1
        }) : W.remove(r));
    };
    if (!e) throw Error(`clientStorageType is set to '${n}' but no clienStorage has been given`);
    if (n === "react-native") return (r, s)=>{
        var t, i;
        return s ? (t = e.setItem) == null ? void 0 : t.call(e, r, s) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
    };
    if (n === "capacitor") return (r, s)=>{
        var t, i;
        return s ? (t = e.set) == null ? void 0 : t.call(e, {
            key: r,
            value: s
        }) : (i = e.remove) == null ? void 0 : i.call(e, {
            key: r
        });
    };
    if (n === "expo-secure-storage") return async (r, s)=>{
        var t, i;
        return s ? (t = e.setItemAsync) == null ? void 0 : t.call(e, r, s) : (i = e.deleteItemAsync) == null ? void 0 : i.call(e, r);
    };
    if (n === "custom") {
        if (!e.removeItem) throw Error("clientStorageType is set to 'custom' but clientStorage is missing a removeItem property");
        if (e.setItem) return (r, s)=>{
            var t, i;
            return s ? (t = e.setItem) == null ? void 0 : t.call(e, r, s) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
        };
        if (e.setItemAsync) return async (r, s)=>{
            var t, i;
            return s ? (t = e.setItemAsync) == null ? void 0 : t.call(e, r, s) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
        };
        throw Error("clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property");
    }
    throw Error(`Unknown storage type: ${n}`);
}, C = (n)=>!n || !n.accessToken.value || !n.accessToken.expiresAt || !n.user ? null : {
        accessToken: n.accessToken.value,
        accessTokenExpiresIn: (n.accessToken.expiresAt.getTime() - Date.now()) / 1e3,
        refreshToken: n.refreshToken.value,
        user: n.user
    }, _ = ({ accessToken: n, refreshToken: e, isError: r, user: s, error: t })=>r ? {
        session: null,
        error: t
    } : s && n ? {
        session: {
            accessToken: n,
            accessTokenExpiresIn: 0,
            refreshToken: e,
            user: s
        },
        error: null
    } : {
        session: null,
        error: null
    }, M = ()=>("TURBOPACK compile-time value", "undefined") != "undefined" && typeof window.location != "undefined";
let ke = globalThis.fetch;
typeof EdgeRuntime != "string" && (ke = rr().fetch);
const ye = async (n, e, { token: r, body: s, extraHeaders: t } = {})=>{
    const i = {
        "Content-Type": "application/json",
        Accept: "*/*"
    };
    r && (i.Authorization = `Bearer ${r}`);
    const l = {
        ...i,
        ...t
    }, f = {
        method: e,
        headers: l
    };
    s && (f.body = JSON.stringify(s));
    try {
        const h = await ke(n, f);
        if (!h.ok) {
            const E = await h.json();
            return Promise.reject({
                error: E
            });
        }
        try {
            return {
                data: await h.json(),
                error: null
            };
        } catch  {
            return console.warn(`Unexpected response: can't parse the response of the server at ${n}`), {
                data: "OK",
                error: null
            };
        }
    } catch  {
        const E = {
            message: "Network Error",
            status: J,
            error: "network"
        };
        return Promise.reject({
            error: E
        });
    }
}, I = async (n, e, r, s)=>ye(n, "POST", {
        token: r,
        body: e,
        extraHeaders: s
    }), Ae = (n, e)=>ye(n, "GET", {
        token: e
    }), L = (n, e)=>{
    const r = e && Object.entries(e).map(([s, t])=>{
        const i = Array.isArray(t) ? t.join(",") : typeof t == "object" ? JSON.stringify(t) : t;
        return `${s}=${encodeURIComponent(i)}`;
    }).join("&");
    return r ? `${n}?${r}` : n;
}, R = (n, e)=>{
    if (!(e != null && e.redirectTo)) return e;
    const { redirectTo: r, ...s } = e;
    if (!n) return r.startsWith("/") ? s : e;
    const t = new URL(n), i = Object.fromEntries(new URLSearchParams(t.search)), l = new URL(r.startsWith("/") ? t.origin + r : r), f = new URLSearchParams(l.search);
    let h = Object.fromEntries(f);
    r.startsWith("/") && (h = {
        ...i,
        ...h
    });
    let E = t.pathname;
    return l.pathname.length > 1 && (E += l.pathname.slice(1)), {
        ...s,
        redirectTo: L(l.origin + E, h)
    };
};
function x(n, e) {
    var t;
    if (!e) {
        if ("TURBOPACK compile-time truthy", 1) return;
        //TURBOPACK unreachable
        ;
    }
    n = n.replace(/[\[\]]/g, "\\$&");
    const r = new RegExp("[?&#]" + n + "(=([^&#]*)|&|#|$)"), s = r.exec(e);
    return s ? s[2] ? decodeURIComponent(s[2].replace(/\+/g, " ")) : "" : null;
}
function B(n) {
    var r;
    if ("TURBOPACK compile-time truthy", 1) return;
    //TURBOPACK unreachable
    ;
    const e = undefined;
}
const y = (n)=>!!n && typeof n == "string" && !!String(n).toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/), G = (n)=>!!n && typeof n == "string" && n.length >= ie, Q = (n)=>!!n && typeof n == "string", Pe = (n)=>n && typeof n == "string" && n.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i), ve = ({ backendUrl: n, clientUrl: e, broadcastKey: r, clientStorageType: s = "web", clientStorage: t, refreshIntervalTime: i, autoRefreshToken: l = !0, autoSignIn: f = !0 })=>{
    const h = Re(s, t), E = _e(s, t), g = async (a, o, c, d)=>(await I(`${n}${a}`, o, c, d)).data;
    let T = null;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        context: U,
        predictableActionArguments: !0,
        id: "nhost",
        type: "parallel",
        states: {
            authentication: {
                initial: "starting",
                on: {
                    SESSION_UPDATE: [
                        {
                            cond: "hasSession",
                            actions: [
                                "saveSession",
                                "resetTimer",
                                "reportTokenChanged"
                            ],
                            target: ".signedIn"
                        }
                    ]
                },
                states: {
                    starting: {
                        tags: [
                            "loading"
                        ],
                        always: {
                            cond: "isSignedIn",
                            target: "signedIn"
                        },
                        invoke: {
                            id: "importRefreshToken",
                            src: "importRefreshToken",
                            onDone: [
                                {
                                    cond: "hasSession",
                                    actions: [
                                        "saveSession",
                                        "reportTokenChanged"
                                    ],
                                    target: "signedIn"
                                },
                                {
                                    target: "signedOut"
                                }
                            ],
                            onError: [
                                {
                                    cond: "shouldRetryImportToken",
                                    actions: "incrementTokenImportAttempts",
                                    target: "retryTokenImport"
                                },
                                {
                                    actions: [
                                        "saveAuthenticationError"
                                    ],
                                    target: "signedOut"
                                }
                            ]
                        }
                    },
                    retryTokenImport: {
                        tags: [
                            "loading"
                        ],
                        after: {
                            RETRY_IMPORT_TOKEN_DELAY: "starting"
                        }
                    },
                    signedOut: {
                        initial: "noErrors",
                        entry: "reportSignedOut",
                        states: {
                            noErrors: {},
                            success: {},
                            needsSmsOtp: {},
                            needsMfa: {},
                            failed: {},
                            signingOut: {
                                entry: [
                                    "clearContextExceptTokens"
                                ],
                                exit: [
                                    "destroyAccessToken",
                                    "destroyRefreshToken",
                                    "reportTokenChanged"
                                ],
                                invoke: {
                                    src: "signout",
                                    id: "signingOut",
                                    onDone: {
                                        target: "success"
                                    },
                                    onError: {
                                        target: "failed",
                                        actions: [
                                            "saveAuthenticationError"
                                        ]
                                    }
                                }
                            }
                        },
                        on: {
                            SIGNIN_PASSWORD: "authenticating.password",
                            SIGNIN_ANONYMOUS: "authenticating.anonymous",
                            SIGNIN_SECURITY_KEY_EMAIL: "authenticating.securityKeyEmail",
                            SIGNIN_SECURITY_KEY: "authenticating.securityKey",
                            SIGNIN_MFA_TOTP: "authenticating.mfa.totp",
                            SIGNIN_PAT: "authenticating.pat",
                            SIGNIN_ID_TOKEN: "authenticating.idToken"
                        }
                    },
                    authenticating: {
                        entry: "resetErrors",
                        states: {
                            password: {
                                invoke: {
                                    src: "signInPassword",
                                    id: "authenticateUserWithPassword",
                                    onDone: [
                                        {
                                            cond: "hasMfaTicket",
                                            actions: [
                                                "saveMfaTicket"
                                            ],
                                            target: "#nhost.authentication.signedOut.needsMfa"
                                        },
                                        {
                                            actions: [
                                                "saveSession",
                                                "reportTokenChanged"
                                            ],
                                            target: "#nhost.authentication.signedIn"
                                        }
                                    ],
                                    onError: [
                                        {
                                            cond: "unverified",
                                            target: [
                                                "#nhost.authentication.signedOut",
                                                "#nhost.registration.incomplete.needsEmailVerification"
                                            ]
                                        },
                                        {
                                            actions: "saveAuthenticationError",
                                            target: "#nhost.authentication.signedOut.failed"
                                        }
                                    ]
                                }
                            },
                            pat: {
                                invoke: {
                                    src: "signInPAT",
                                    id: "authenticateWithPAT",
                                    onDone: {
                                        actions: [
                                            "savePATSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: {
                                        actions: "saveAuthenticationError",
                                        target: "#nhost.authentication.signedOut.failed"
                                    }
                                }
                            },
                            idToken: {
                                invoke: {
                                    src: "signInIdToken",
                                    id: "authenticateWithIdToken",
                                    onDone: {
                                        actions: [
                                            "saveSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: {
                                        actions: "saveAuthenticationError",
                                        target: "#nhost.authentication.signedOut.failed"
                                    }
                                }
                            },
                            anonymous: {
                                invoke: {
                                    src: "signInAnonymous",
                                    id: "authenticateAnonymously",
                                    onDone: {
                                        actions: [
                                            "saveSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: {
                                        actions: "saveAuthenticationError",
                                        target: "#nhost.authentication.signedOut.failed"
                                    }
                                }
                            },
                            mfa: {
                                states: {
                                    totp: {
                                        invoke: {
                                            src: "signInMfaTotp",
                                            id: "signInMfaTotp",
                                            onDone: {
                                                actions: [
                                                    "saveSession",
                                                    "reportTokenChanged"
                                                ],
                                                target: "#nhost.authentication.signedIn"
                                            },
                                            onError: {
                                                actions: [
                                                    "saveAuthenticationError"
                                                ],
                                                target: "#nhost.authentication.signedOut.failed"
                                            }
                                        }
                                    }
                                }
                            },
                            securityKeyEmail: {
                                invoke: {
                                    src: "signInSecurityKeyEmail",
                                    id: "authenticateUserWithSecurityKey",
                                    onDone: {
                                        actions: [
                                            "saveSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: [
                                        {
                                            cond: "unverified",
                                            target: [
                                                "#nhost.authentication.signedOut",
                                                "#nhost.registration.incomplete.needsEmailVerification"
                                            ]
                                        },
                                        {
                                            actions: "saveAuthenticationError",
                                            target: "#nhost.authentication.signedOut.failed"
                                        }
                                    ]
                                }
                            },
                            securityKey: {
                                invoke: {
                                    src: "signInSecurityKey",
                                    id: "authenticateUserWithSecurityKey",
                                    onDone: {
                                        actions: [
                                            "saveSession",
                                            "reportTokenChanged"
                                        ],
                                        target: "#nhost.authentication.signedIn"
                                    },
                                    onError: [
                                        {
                                            cond: "unverified",
                                            target: [
                                                "#nhost.authentication.signedOut",
                                                "#nhost.registration.incomplete.needsEmailVerification"
                                            ]
                                        },
                                        {
                                            actions: "saveAuthenticationError",
                                            target: "#nhost.authentication.signedOut.failed"
                                        }
                                    ]
                                }
                            }
                        }
                    },
                    signedIn: {
                        type: "parallel",
                        entry: [
                            "reportSignedIn",
                            "cleanUrl",
                            "broadcastToken",
                            "resetErrors"
                        ],
                        on: {
                            SIGNOUT: "signedOut.signingOut"
                        },
                        states: {
                            refreshTimer: {
                                id: "timer",
                                initial: "idle",
                                states: {
                                    disabled: {
                                        type: "final"
                                    },
                                    stopped: {
                                        always: {
                                            cond: "noToken",
                                            target: "idle"
                                        }
                                    },
                                    idle: {
                                        always: [
                                            {
                                                cond: "isAutoRefreshDisabled",
                                                target: "disabled"
                                            },
                                            {
                                                cond: "isRefreshTokenPAT",
                                                target: "disabled"
                                            },
                                            {
                                                cond: "hasRefreshToken",
                                                target: "running"
                                            }
                                        ]
                                    },
                                    running: {
                                        initial: "pending",
                                        entry: "resetTimer",
                                        states: {
                                            pending: {
                                                after: {
                                                    1e3: {
                                                        internal: !1,
                                                        target: "pending"
                                                    }
                                                },
                                                always: {
                                                    cond: "refreshTimerShouldRefresh",
                                                    target: "refreshing"
                                                }
                                            },
                                            refreshing: {
                                                invoke: {
                                                    src: "refreshToken",
                                                    id: "refreshToken",
                                                    onDone: {
                                                        actions: [
                                                            "saveSession",
                                                            "resetTimer",
                                                            "reportTokenChanged",
                                                            "broadcastToken"
                                                        ],
                                                        target: "pending"
                                                    },
                                                    onError: [
                                                        {
                                                            cond: "isUnauthorizedError",
                                                            target: "#nhost.authentication.signedOut"
                                                        },
                                                        {
                                                            actions: "saveRefreshAttempt",
                                                            target: "pending"
                                                        }
                                                    ]
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
            token: {
                initial: "idle",
                states: {
                    idle: {
                        on: {
                            TRY_TOKEN: "running"
                        },
                        initial: "noErrors",
                        states: {
                            noErrors: {},
                            error: {}
                        }
                    },
                    running: {
                        invoke: {
                            src: "refreshToken",
                            id: "authenticateWithToken",
                            onDone: {
                                actions: [
                                    "saveSession",
                                    "reportTokenChanged",
                                    "broadcastToken"
                                ],
                                target: [
                                    "#nhost.authentication.signedIn",
                                    "idle.noErrors"
                                ]
                            },
                            onError: [
                                {
                                    cond: "isSignedIn",
                                    target: "idle.error"
                                },
                                {
                                    actions: "saveAuthenticationError",
                                    target: [
                                        "#nhost.authentication.signedOut.failed",
                                        "idle.error"
                                    ]
                                }
                            ]
                        }
                    }
                }
            },
            registration: {
                initial: "incomplete",
                on: {
                    SIGNED_IN: [
                        {
                            cond: "isAnonymous",
                            target: ".incomplete"
                        },
                        ".complete"
                    ]
                },
                states: {
                    incomplete: {
                        on: {
                            SIGNUP_EMAIL_PASSWORD: "emailPassword",
                            SIGNUP_SECURITY_KEY: "securityKey",
                            PASSWORDLESS_EMAIL: "passwordlessEmail",
                            PASSWORDLESS_SMS: "passwordlessSms",
                            PASSWORDLESS_SMS_OTP: "passwordlessSmsOtp",
                            SIGNIN_EMAIL_OTP: "signInEmailOTP",
                            VERIFY_EMAIL_OTP: "verifyEmailOTP"
                        },
                        initial: "noErrors",
                        states: {
                            noErrors: {},
                            needsEmailVerification: {},
                            needsOtp: {},
                            failed: {}
                        }
                    },
                    emailPassword: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "signUpEmailPassword",
                            id: "signUpEmailPassword",
                            onDone: [
                                {
                                    cond: "hasSession",
                                    actions: [
                                        "saveSession",
                                        "reportTokenChanged"
                                    ],
                                    target: "#nhost.authentication.signedIn"
                                },
                                {
                                    actions: "clearContext",
                                    target: [
                                        "#nhost.authentication.signedOut",
                                        "incomplete.needsEmailVerification"
                                    ]
                                }
                            ],
                            onError: [
                                {
                                    cond: "unverified",
                                    target: "incomplete.needsEmailVerification"
                                },
                                {
                                    actions: "saveRegistrationError",
                                    target: "incomplete.failed"
                                }
                            ]
                        }
                    },
                    securityKey: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "signUpSecurityKey",
                            id: "signUpSecurityKey",
                            onDone: [
                                {
                                    cond: "hasSession",
                                    actions: [
                                        "saveSession",
                                        "reportTokenChanged"
                                    ],
                                    target: "#nhost.authentication.signedIn"
                                },
                                {
                                    actions: "clearContext",
                                    target: [
                                        "#nhost.authentication.signedOut",
                                        "incomplete.needsEmailVerification"
                                    ]
                                }
                            ],
                            onError: [
                                {
                                    cond: "unverified",
                                    target: "incomplete.needsEmailVerification"
                                },
                                {
                                    actions: "saveRegistrationError",
                                    target: "incomplete.failed"
                                }
                            ]
                        }
                    },
                    passwordlessEmail: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "passwordlessEmail",
                            id: "passwordlessEmail",
                            onDone: {
                                actions: "clearContext",
                                target: [
                                    "#nhost.authentication.signedOut",
                                    "incomplete.needsEmailVerification"
                                ]
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    passwordlessSms: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "passwordlessSms",
                            id: "passwordlessSms",
                            onDone: {
                                actions: "clearContext",
                                target: [
                                    "#nhost.authentication.signedOut",
                                    "incomplete.needsOtp"
                                ]
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    passwordlessSmsOtp: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "passwordlessSmsOtp",
                            id: "passwordlessSmsOtp",
                            onDone: {
                                actions: [
                                    "saveSession",
                                    "reportTokenChanged"
                                ],
                                target: "#nhost.authentication.signedIn"
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    signInEmailOTP: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "signInEmailOTP",
                            id: "signInEmailOTP",
                            onDone: {
                                actions: "clearContext",
                                target: [
                                    "#nhost.authentication.signedOut",
                                    "incomplete.needsOtp"
                                ]
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    verifyEmailOTP: {
                        entry: [
                            "resetErrors"
                        ],
                        invoke: {
                            src: "verifyEmailOTP",
                            id: "verifyEmailOTP",
                            onDone: {
                                actions: [
                                    "saveSession",
                                    "reportTokenChanged"
                                ],
                                target: "#nhost.authentication.signedIn"
                            },
                            onError: {
                                actions: "saveRegistrationError",
                                target: "incomplete.failed"
                            }
                        }
                    },
                    complete: {
                        on: {
                            SIGNED_OUT: "incomplete"
                        }
                    }
                }
            }
        }
    }, {
        actions: {
            reportSignedIn: u.send("SIGNED_IN"),
            reportSignedOut: u.send("SIGNED_OUT"),
            reportTokenChanged: u.send("TOKEN_CHANGED"),
            incrementTokenImportAttempts: u.assign({
                importTokenAttempts: ({ importTokenAttempts: a })=>a + 1
            }),
            clearContext: u.assign(()=>(E(v, null), E(N, null), E(D, null), {
                    ...U
                })),
            clearContextExceptTokens: u.assign(({ accessToken: a, refreshToken: o })=>({
                    ...U,
                    accessToken: a,
                    refreshToken: o
                })),
            saveSession: u.assign({
                user: (a, { data: o })=>{
                    var c;
                    return ((c = o == null ? void 0 : o.session) == null ? void 0 : c.user) || null;
                },
                accessToken: (a, { data: o })=>{
                    if (o.session) {
                        const { accessTokenExpiresIn: c, accessToken: d } = o.session, m = new Date(Date.now() + c * 1e3);
                        return E(v, m.toISOString()), {
                            value: d,
                            expiresAt: m,
                            expiresInSeconds: c
                        };
                    }
                    return E(v, null), {
                        value: null,
                        expiresAt: null,
                        expiresInSeconds: null
                    };
                },
                refreshToken: (a, { data: o })=>{
                    var m, S;
                    const c = ((m = o.session) == null ? void 0 : m.refreshToken) || null, d = ((S = o.session) == null ? void 0 : S.refreshTokenId) || null;
                    return c && E(N, c), d && E(D, d), {
                        value: c
                    };
                }
            }),
            savePATSession: u.assign({
                user: (a, { data: o })=>{
                    var c;
                    return ((c = o == null ? void 0 : o.session) == null ? void 0 : c.user) || null;
                },
                accessToken: (a, { data: o })=>{
                    if (o.session) {
                        const { accessTokenExpiresIn: c, accessToken: d } = o.session, m = new Date(Date.now() + c * 1e3);
                        return E(v, m.toISOString()), {
                            value: d,
                            expiresAt: m,
                            expiresInSeconds: c
                        };
                    }
                    return E(v, null), {
                        value: null,
                        expiresAt: null,
                        expiresInSeconds: null
                    };
                },
                refreshToken: (a, { data: o })=>{
                    var m, S;
                    const c = ((m = o.session) == null ? void 0 : m.refreshToken) || null, d = ((S = o.session) == null ? void 0 : S.refreshTokenId) || null;
                    return c && E(N, c), d && E(D, d), {
                        value: c,
                        isPAT: !0
                    };
                }
            }),
            saveMfaTicket: u.assign({
                mfa: (a, o)=>{
                    var c;
                    return (c = o.data) == null ? void 0 : c.mfa;
                }
            }),
            resetTimer: u.assign({
                refreshTimer: (a)=>({
                        startedAt: new Date,
                        attempts: 0,
                        lastAttempt: null
                    })
            }),
            saveRefreshAttempt: u.assign({
                refreshTimer: (a, o)=>({
                        startedAt: a.refreshTimer.startedAt,
                        attempts: a.refreshTimer.attempts + 1,
                        lastAttempt: new Date
                    })
            }),
            saveAuthenticationError: u.assign({
                errors: ({ errors: a }, { data: { error: o } })=>({
                        ...a,
                        authentication: o
                    })
            }),
            resetErrors: u.assign({
                errors: (a)=>({}),
                importTokenAttempts: (a)=>0
            }),
            saveRegistrationError: u.assign({
                errors: ({ errors: a }, { data: { error: o } })=>({
                        ...a,
                        registration: o
                    })
            }),
            destroyRefreshToken: u.assign({
                refreshToken: (a)=>(E(N, null), E(D, null), {
                        value: null
                    })
            }),
            destroyAccessToken: u.assign({
                accessToken: (a)=>(E(v, null), {
                        value: null,
                        expiresAt: null,
                        expiresInSeconds: null
                    })
            }),
            cleanUrl: ()=>{
                f && x("refreshToken") && (B("refreshToken"), B("type"));
            },
            broadcastToken: (a)=>{
                if (f && r && T) try {
                    T.postMessage({
                        type: "broadcast_session",
                        payload: {
                            token: a.refreshToken.value,
                            accessToken: a.accessToken.value,
                            user: a.user,
                            expiresAt: a.accessToken.expiresAt ? a.accessToken.expiresAt.toISOString() : null,
                            expiresInSeconds: a.accessToken.expiresInSeconds
                        }
                    });
                } catch  {}
            }
        },
        guards: {
            isAnonymous: (a, o)=>{
                var c;
                return !!((c = a.user) != null && c.isAnonymous);
            },
            isSignedIn: (a)=>!!a.user && !!a.accessToken.value,
            noToken: (a)=>!a.refreshToken.value,
            isRefreshTokenPAT: (a)=>{
                var o;
                return !!((o = a.refreshToken) != null && o.isPAT);
            },
            hasRefreshToken: (a)=>!!a.refreshToken.value,
            isAutoRefreshDisabled: ()=>!l,
            refreshTimerShouldRefresh: (a)=>{
                const { expiresAt: o } = a.accessToken;
                if (!o) return !1;
                if (a.refreshTimer.lastAttempt) return a.refreshTimer.attempts > F ? !1 : Date.now() - a.refreshTimer.lastAttempt.getTime() > Math.pow(2, a.refreshTimer.attempts - 1) * 5e3;
                if (o.getTime() < Date.now() || i && Date.now() - a.refreshTimer.startedAt.getTime() > i * 1e3) return !0;
                if (!a.accessToken.expiresInSeconds) return !1;
                const d = o.getTime() - Date.now();
                return d <= Y * 1e3 / 2 || d <= Y * 1e3 && Math.random() < .1;
            },
            shouldRetryImportToken: (a, o)=>a.importTokenAttempts < F && (o.data.error.status === J || o.data.error.status >= 500),
            unverified: (a, { data: { error: o } })=>o.status === 401 && (o.message === "Email is not verified" || o.error === "unverified-user"),
            hasSession: (a, o)=>{
                var c;
                return !!((c = o.data) != null && c.session);
            },
            hasMfaTicket: (a, o)=>{
                var c;
                return !!((c = o.data) != null && c.mfa);
            },
            isUnauthorizedError: (a, { data: { error: o } })=>o.status === 401
        },
        services: {
            signInPassword: (a, { email: o, password: c })=>y(o) ? G(c) ? g("/signin/email-password", {
                    email: o,
                    password: c
                }) : Promise.reject({
                    error: V
                }) : Promise.reject({
                    error: k
                }),
            signInPAT: (a, { pat: o })=>g("/signin/pat", {
                    personalAccessToken: o
                }),
            signInIdToken: (a, { provider: o, idToken: c, nonce: d })=>g("/signin/idtoken", {
                    provider: o,
                    idToken: c,
                    ...d && {
                        nonce: d
                    }
                }),
            passwordlessSms: (a, { phoneNumber: o, options: c })=>{
                var d;
                return Q(o) ? (d = a.user) != null && d.isAnonymous ? (console.warn("Deanonymisation from a phone number is not yet implemented in hasura-auth"), g("/user/deanonymize", {
                    signInMethod: "passwordless",
                    connection: "sms",
                    phoneNumber: o,
                    options: R(e, c)
                }, a.accessToken.value)) : g("/signin/passwordless/sms", {
                    phoneNumber: o,
                    options: R(e, c)
                }) : Promise.reject({
                    error: j
                });
            },
            passwordlessSmsOtp: (a, { phoneNumber: o, otp: c })=>Q(o) ? g("/signin/passwordless/sms/otp", {
                    phoneNumber: o,
                    otp: c
                }) : Promise.reject({
                    error: j
                }),
            signInEmailOTP: (a, { email: o, options: c })=>y(o) ? g("/signin/otp/email", {
                    email: o,
                    options: R(e, c)
                }) : Promise.reject({
                    error: k
                }),
            verifyEmailOTP: (a, { email: o, otp: c })=>y(o) ? g("/signin/otp/email/verify", {
                    email: o,
                    otp: c
                }) : Promise.reject({
                    error: k
                }),
            passwordlessEmail: (a, { email: o, options: c })=>{
                var d;
                return y(o) ? (d = a.user) != null && d.isAnonymous ? g("/user/deanonymize", {
                    signInMethod: "passwordless",
                    connection: "email",
                    email: o,
                    options: R(e, c)
                }, a.accessToken.value) : g("/signin/passwordless/email", {
                    email: o,
                    options: R(e, c)
                }) : Promise.reject({
                    error: k
                });
            },
            signInAnonymous: (a)=>g("/signin/anonymous"),
            signInMfaTotp: (a, o)=>{
                var d;
                const c = o.ticket || ((d = a.mfa) == null ? void 0 : d.ticket);
                return c ? Pe(c) ? g("/signin/mfa/totp", {
                    ticket: c,
                    otp: o.otp
                }) : Promise.reject({
                    error: ce
                }) : Promise.reject({
                    error: le
                });
            },
            signInSecurityKeyEmail: async (a, { email: o })=>{
                if (!y(o)) throw new O(k);
                const c = await g("/signin/webauthn", {
                    email: o
                });
                let d;
                try {
                    d = await q(c);
                } catch (m) {
                    throw new O(m);
                }
                return g("/signin/webauthn/verify", {
                    email: o,
                    credential: d
                });
            },
            refreshToken: async (a, o)=>{
                const c = o.type === "TRY_TOKEN" ? o.token : a.refreshToken.value;
                return {
                    session: await g("/token", {
                        refreshToken: c
                    }),
                    error: null
                };
            },
            signInSecurityKey: async ()=>{
                try {
                    const a = await g("/signin/webauthn", {});
                    let o;
                    try {
                        o = await q(a);
                    } catch (c) {
                        throw new O(c);
                    }
                    return g("/signin/webauthn/verify", {
                        credential: o
                    });
                } catch (a) {
                    throw new O(a);
                }
            },
            signout: async (a, o)=>{
                const c = await g("/signout", {
                    refreshToken: a.refreshToken.value,
                    all: !!o.all
                }, o.all ? a.accessToken.value : void 0);
                if (r && T) try {
                    T.postMessage({
                        type: "signout"
                    });
                } catch  {}
                return c;
            },
            signUpEmailPassword: async (a, { email: o, password: c, options: d, requestOptions: m })=>{
                var S;
                return y(o) ? G(c) ? (S = a.user) != null && S.isAnonymous ? g("/user/deanonymize", {
                    signInMethod: "email-password",
                    email: o,
                    password: c,
                    options: R(e, d)
                }, a.accessToken.value, m == null ? void 0 : m.headers) : g("/signup/email-password", {
                    email: o,
                    password: c,
                    options: R(e, d)
                }, null, m == null ? void 0 : m.headers) : Promise.reject({
                    error: V
                }) : Promise.reject({
                    error: k
                });
            },
            signUpSecurityKey: async (a, { email: o, options: c, requestOptions: d })=>{
                if (!y(o)) return Promise.reject({
                    error: k
                });
                const m = c == null ? void 0 : c.nickname;
                m && delete c.nickname;
                const S = await g("/signup/webauthn", {
                    email: o,
                    options: c
                }, null, d == null ? void 0 : d.headers);
                let ne;
                try {
                    ne = await Se(S);
                } catch (Je) {
                    throw new O(Je);
                }
                return g("/signup/webauthn/verify", {
                    credential: ne,
                    options: {
                        redirectTo: c == null ? void 0 : c.redirectTo,
                        nickname: m,
                        displayName: c == null ? void 0 : c.displayName,
                        ...(c == null ? void 0 : c.metadata) && {
                            metadata: c == null ? void 0 : c.metadata
                        }
                    }
                });
            },
            importRefreshToken: async (a)=>{
                if (a.user && a.refreshToken.value && a.accessToken.value && a.accessToken.expiresAt) return {
                    session: {
                        accessToken: a.accessToken.value,
                        accessTokenExpiresIn: a.accessToken.expiresAt.getTime() - Date.now(),
                        refreshToken: a.refreshToken.value,
                        user: a.user
                    },
                    error: null
                };
                let o = null;
                if (f) {
                    const d = x("refreshToken") || null;
                    if (d) try {
                        return {
                            session: await g("/token", {
                                refreshToken: d
                            }),
                            error: null
                        };
                    } catch (m) {
                        o = m.error;
                    }
                    else {
                        const m = x("error"), S = x("errorDescription");
                        if (m && S !== "social user already exists") return Promise.reject({
                            session: null,
                            error: {
                                status: A,
                                error: m,
                                message: S || m
                            }
                        });
                    }
                }
                const c = await h(N);
                if (c) try {
                    return {
                        session: await g("/token", {
                            refreshToken: c
                        }),
                        error: null
                    };
                } catch (d) {
                    o = d.error;
                }
                return o ? Promise.reject({
                    error: o,
                    session: null
                }) : {
                    error: null,
                    session: null
                };
            }
        },
        delays: {
            RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts: a })=>Math.pow(2, a - 1) * 5e3
        }
    });
}, Oe = ({ backendUrl: n, clientUrl: e, interpreter: r })=>u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "changeEmail",
        initial: "idle",
        context: {
            error: null
        },
        states: {
            idle: {
                on: {
                    REQUEST: [
                        {
                            cond: "invalidEmail",
                            actions: "saveInvalidEmailError",
                            target: ".error"
                        },
                        {
                            target: "requesting"
                        }
                    ]
                },
                initial: "initial",
                states: {
                    initial: {},
                    success: {},
                    error: {}
                }
            },
            requesting: {
                invoke: {
                    src: "requestChange",
                    id: "requestChange",
                    onDone: {
                        target: "idle.success",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveRequestError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidEmailError: u.assign({
                error: (s)=>k
            }),
            saveRequestError: u.assign({
                error: (s, { data: { error: t } })=>t
            }),
            reportError: u.send((s)=>({
                    type: "ERROR",
                    error: s.error
                })),
            reportSuccess: u.send("SUCCESS")
        },
        guards: {
            invalidEmail: (s, { email: t })=>!y(t)
        },
        services: {
            requestChange: async (s, { email: t, options: i })=>(await I(`${n}/user/email/change`, {
                    newEmail: t,
                    options: R(e, i)
                }, r == null ? void 0 : r.getSnapshot().context.accessToken.value)).data
        }
    }), Ne = ({ backendUrl: n, interpreter: e })=>u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "changePassword",
        initial: "idle",
        context: {
            error: null
        },
        states: {
            idle: {
                on: {
                    REQUEST: [
                        {
                            cond: "invalidPassword",
                            actions: "saveInvalidPasswordError",
                            target: ".error"
                        },
                        {
                            target: "requesting"
                        }
                    ]
                },
                initial: "initial",
                states: {
                    initial: {},
                    success: {},
                    error: {}
                }
            },
            requesting: {
                invoke: {
                    src: "requestChange",
                    id: "requestChange",
                    onDone: {
                        target: "idle.success",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveRequestError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidPasswordError: u.assign({
                error: (r)=>V
            }),
            saveRequestError: u.assign({
                error: (r, { data: { error: s } })=>s
            }),
            reportError: u.send((r)=>({
                    type: "ERROR",
                    error: r.error
                })),
            reportSuccess: u.send("SUCCESS")
        },
        guards: {
            invalidPassword: (r, { password: s })=>!G(s)
        },
        services: {
            requestChange: (r, { password: s, ticket: t })=>I(`${n}/user/password`, {
                    newPassword: s,
                    ticket: t
                }, e == null ? void 0 : e.getSnapshot().context.accessToken.value)
        }
    }), hr = ({ backendUrl: n, interpreter: e })=>u.createMachine({
        schema: {
            context: {},
            events: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "enableMfa",
        initial: "idle",
        context: {
            error: null,
            imageUrl: null,
            secret: null
        },
        states: {
            idle: {
                initial: "initial",
                on: {
                    GENERATE: "generating",
                    DISABLE: "disabling"
                },
                states: {
                    initial: {},
                    error: {},
                    disabled: {}
                }
            },
            generating: {
                invoke: {
                    src: "generate",
                    id: "generate",
                    onDone: {
                        target: "generated",
                        actions: [
                            "reportGeneratedSuccess",
                            "saveGeneration"
                        ]
                    },
                    onError: {
                        actions: [
                            "saveError",
                            "reportGeneratedError"
                        ],
                        target: "idle.error"
                    }
                }
            },
            generated: {
                initial: "idle",
                states: {
                    idle: {
                        initial: "idle",
                        on: {
                            ACTIVATE: [
                                {
                                    cond: "invalidMfaType",
                                    actions: "saveInvalidMfaTypeError",
                                    target: ".error"
                                },
                                {
                                    cond: "invalidMfaCode",
                                    actions: "saveInvalidMfaCodeError",
                                    target: ".error"
                                },
                                {
                                    target: "activating"
                                }
                            ],
                            DISABLE: "#enableMfa.disabling"
                        },
                        states: {
                            idle: {},
                            error: {}
                        }
                    },
                    activating: {
                        invoke: {
                            src: "activate",
                            id: "activate",
                            onDone: {
                                target: "activated",
                                actions: "reportSuccess"
                            },
                            onError: {
                                actions: [
                                    "saveError",
                                    "reportError"
                                ],
                                target: "idle.error"
                            }
                        }
                    },
                    activated: {
                        type: "final"
                    }
                }
            },
            disabling: {
                invoke: {
                    src: "disable",
                    id: "disable",
                    onDone: {
                        target: "idle.disabled",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidMfaTypeError: u.assign({
                error: (r)=>oe
            }),
            saveInvalidMfaCodeError: u.assign({
                error: (r)=>ae
            }),
            saveError: u.assign({
                error: (r, { data: { error: s } })=>s
            }),
            saveGeneration: u.assign({
                imageUrl: (r, { data: { imageUrl: s } })=>s,
                secret: (r, { data: { totpSecret: s } })=>s
            }),
            reportError: u.send((r, s)=>({
                    type: "ERROR",
                    error: r.error
                })),
            reportSuccess: u.send("SUCCESS"),
            reportGeneratedSuccess: u.send("GENERATED"),
            reportGeneratedError: u.send((r)=>({
                    type: "GENERATED_ERROR",
                    error: r.error
                }))
        },
        guards: {
            invalidMfaCode: (r, { code: s })=>!s,
            invalidMfaType: (r, { activeMfaType: s })=>!s || s !== "totp"
        },
        services: {
            generate: async (r)=>{
                const { data: s } = await Ae(`${n}/mfa/totp/generate`, e == null ? void 0 : e.getSnapshot().context.accessToken.value);
                return s;
            },
            activate: (r, { code: s, activeMfaType: t })=>I(`${n}/user/mfa`, {
                    code: s,
                    activeMfaType: t
                }, e == null ? void 0 : e.getSnapshot().context.accessToken.value),
            disable: (r, { code: s })=>I(`${n}/user/mfa`, {
                    code: s,
                    activeMfaType: ""
                }, e == null ? void 0 : e.getSnapshot().context.accessToken.value)
        }
    }), be = ({ backendUrl: n, clientUrl: e })=>u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "changePassword",
        initial: "idle",
        context: {
            error: null
        },
        states: {
            idle: {
                on: {
                    REQUEST: [
                        {
                            cond: "invalidEmail",
                            actions: "saveInvalidEmailError",
                            target: ".error"
                        },
                        {
                            target: "requesting"
                        }
                    ]
                },
                initial: "initial",
                states: {
                    initial: {},
                    success: {},
                    error: {}
                }
            },
            requesting: {
                invoke: {
                    src: "requestChange",
                    id: "requestChange",
                    onDone: {
                        target: "idle.success",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveRequestError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidEmailError: u.assign({
                error: (r)=>k
            }),
            saveRequestError: u.assign({
                error: (r, { data: { error: s } })=>s
            }),
            reportError: u.send((r)=>({
                    type: "ERROR",
                    error: r.error
                })),
            reportSuccess: u.send("SUCCESS")
        },
        guards: {
            invalidEmail: (r, { email: s })=>!y(s)
        },
        services: {
            requestChange: (r, { email: s, options: t })=>I(`${n}/user/password/reset`, {
                    email: s,
                    options: R(e, t)
                })
        }
    }), De = ({ backendUrl: n, clientUrl: e })=>u.createMachine({
        schema: {
            context: {},
            events: {},
            services: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        id: "sendVerificationEmail",
        initial: "idle",
        context: {
            error: null
        },
        states: {
            idle: {
                on: {
                    REQUEST: [
                        {
                            cond: "invalidEmail",
                            actions: "saveInvalidEmailError",
                            target: ".error"
                        },
                        {
                            target: "requesting"
                        }
                    ]
                },
                initial: "initial",
                states: {
                    initial: {},
                    success: {},
                    error: {}
                }
            },
            requesting: {
                invoke: {
                    src: "request",
                    id: "request",
                    onDone: {
                        target: "idle.success",
                        actions: "reportSuccess"
                    },
                    onError: {
                        actions: [
                            "saveRequestError",
                            "reportError"
                        ],
                        target: "idle.error"
                    }
                }
            }
        }
    }, {
        actions: {
            saveInvalidEmailError: u.assign({
                error: (r)=>k
            }),
            saveRequestError: u.assign({
                error: (r, { data: { error: s } })=>s
            }),
            reportError: u.send((r)=>({
                    type: "ERROR",
                    error: r.error
                })),
            reportSuccess: u.send("SUCCESS")
        },
        guards: {
            invalidEmail: (r, { email: s })=>!y(s)
        },
        services: {
            request: async (r, { email: s, options: t })=>(await I(`${n}/user/email/send-verification-email`, {
                    email: s,
                    options: R(e, t)
                })).data
        }
    });
class se {
    constructor({ clientStorageType: e = "web", autoSignIn: r = !0, autoRefreshToken: s = !0, start: t = !0, backendUrl: i, clientUrl: l, broadcastKey: f, devTools: h, ...E }){
        var g;
        if (this._started = !1, this._subscriptionsQueue = new Set, this._subscriptions = new Set, this.backendUrl = i, this.clientUrl = l, this._machine = ve({
            ...E,
            backendUrl: i,
            clientUrl: l,
            broadcastKey: f,
            clientStorageType: e,
            autoSignIn: r,
            autoRefreshToken: s
        }), t && this.start({
            devTools: h
        }), ("TURBOPACK compile-time value", "undefined") != "undefined" && f) try {
            this._channel = new BroadcastChannel(f), r && ((g = this._channel) == null || g.addEventListener("message", (T)=>{
                var c;
                const { type: a, payload: o } = T.data;
                if (a === "broadcast_session") {
                    const d = (c = this.interpreter) == null ? void 0 : c.getSnapshot().context, m = d == null ? void 0 : d.refreshToken.value;
                    this.interpreter && o.token && o.token !== m && this.interpreter.send("SESSION_UPDATE", {
                        data: {
                            session: {
                                user: o.user,
                                accessToken: o.accessToken,
                                refreshToken: o.token,
                                accessTokenExpiresIn: o.expiresInSeconds
                            }
                        }
                    });
                }
            })), this._channel.addEventListener("message", (T)=>{
                const { type: a } = T.data;
                a === "signout" && this.interpreter && this.interpreter.send("SIGNOUT");
            });
        } catch  {}
    }
    start({ devTools: e = !1, initialSession: r, interpreter: s } = {}) {
        var l, f;
        const t = {
            ...this.machine.context,
            accessToken: {
                ...this.machine.context.accessToken
            },
            refreshToken: {
                ...this.machine.context.refreshToken
            }
        };
        r && (t.user = r.user, t.refreshToken.value = (l = r.refreshToken) != null ? l : null, t.accessToken.value = (f = r.accessToken) != null ? f : null, t.accessToken.expiresAt = new Date(Date.now() + r.accessTokenExpiresIn * 1e3));
        const i = this.machine.withContext(t);
        this._interpreter || (this._interpreter = s || u.interpret(i, {
            devTools: e
        })), (!this._started || ("TURBOPACK compile-time value", "undefined") == "undefined") && (this._interpreter.initialized && (this._interpreter.stop(), this._subscriptions.forEach((h)=>h())), this._interpreter.start(i.initialState), this._subscriptionsQueue.forEach((h)=>h(this))), this._started = !0;
    }
    get machine() {
        return this._machine;
    }
    get interpreter() {
        return this._interpreter;
    }
    get started() {
        return this._started;
    }
    subscribe(e) {
        if (this.started) {
            const r = e(this);
            return this._subscriptions.add(r), r;
        } else return this._subscriptionsQueue.add(e), ()=>{
            console.log("onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.");
        };
    }
}
class Ce extends se {
    constructor({ ...e }){
        super({
            ...e,
            autoSignIn: M() && e.autoSignIn,
            autoRefreshToken: M() && e.autoRefreshToken,
            clientStorageType: "cookie"
        });
    }
}
const fr = Ce, xe = async ({ backendUrl: n, interpreter: e }, r)=>{
    try {
        const { data: s } = await I(`${n}/user/webauthn/add`, {}, e == null ? void 0 : e.getSnapshot().context.accessToken.value);
        let t;
        try {
            t = await Se(s);
        } catch (l) {
            throw new O(l);
        }
        const { data: i } = await I(`${n}/user/webauthn/verify`, {
            credential: t,
            nickname: r
        }, e == null ? void 0 : e.getSnapshot().context.accessToken.value);
        return {
            key: i,
            isError: !1,
            error: null,
            isSuccess: !0
        };
    } catch (s) {
        const { error: t } = s;
        return {
            isError: !0,
            error: t,
            isSuccess: !1
        };
    }
}, Me = async (n, e, r)=>new Promise((s)=>{
        n.send("REQUEST", {
            email: e,
            options: r
        }), n.onTransition((t)=>{
            t.matches({
                idle: "error"
            }) ? s({
                error: t.context.error,
                isError: !0,
                needsEmailVerification: !1
            }) : t.matches({
                idle: "success"
            }) && s({
                error: null,
                isError: !1,
                needsEmailVerification: !0
            });
        });
    }), Ue = async (n, e, r)=>new Promise((s)=>{
        n.send("REQUEST", {
            password: e,
            ticket: r
        }), n.onTransition((t)=>{
            t.matches({
                idle: "error"
            }) ? s({
                error: t.context.error,
                isError: !0,
                isSuccess: !1
            }) : t.matches({
                idle: "success"
            }) && s({
                error: null,
                isError: !1,
                isSuccess: !0
            });
        });
    }), Er = (n)=>new Promise((e)=>{
        n.send("GENERATE"), n.onTransition((r)=>{
            r.matches("generated") ? e({
                error: null,
                isError: !1,
                isGenerated: !0,
                qrCodeDataUrl: r.context.imageUrl || "",
                totpSecret: r.context.secret
            }) : r.matches({
                idle: "error"
            }) && e({
                error: r.context.error || null,
                isError: !0,
                isGenerated: !1,
                qrCodeDataUrl: "",
                totpSecret: r.context.secret
            });
        });
    }), mr = (n, e)=>new Promise((r)=>{
        n.send("ACTIVATE", {
            activeMfaType: "totp",
            code: e
        }), n.onTransition((s)=>{
            s.matches({
                generated: "activated"
            }) ? r({
                error: null,
                isActivated: !0,
                isError: !1
            }) : s.matches({
                generated: {
                    idle: "error"
                }
            }) && r({
                error: s.context.error,
                isActivated: !1,
                isError: !0
            });
        });
    }), gr = (n, e)=>new Promise((r)=>{
        n.send("DISABLE", {
            code: e
        }), n.onTransition((s)=>{
            s.matches({
                idle: "disabled"
            }) ? r({
                error: null,
                isDisabled: !0,
                isError: !1
            }) : s.matches({
                idle: "error"
            }) && r({
                error: s.context.error,
                isDisabled: !1,
                isError: !0
            });
        });
    }), Ke = async (n, e, r)=>new Promise((s)=>{
        n.send("REQUEST", {
            email: e,
            options: r
        }), n.onTransition((t)=>{
            t.matches({
                idle: "error"
            }) ? s({
                error: t.context.error,
                isError: !0,
                isSent: !1
            }) : t.matches({
                idle: "success"
            }) && s({
                error: null,
                isError: !1,
                isSent: !0
            });
        });
    }), Ve = (n, e, r)=>new Promise((s)=>{
        n.send("REQUEST", {
            email: e,
            options: r
        }), n.onTransition((t)=>{
            t.matches({
                idle: "error"
            }) ? s({
                error: t.context.error,
                isError: !0,
                isSent: !1
            }) : t.matches({
                idle: "success"
            }) && s({
                error: null,
                isError: !1,
                isSent: !0
            });
        });
    }), Le = (n)=>new Promise((e)=>{
        const { changed: r } = n.send("SIGNIN_ANONYMOUS");
        r || e({
            isSuccess: !1,
            isError: !0,
            error: w,
            user: null,
            accessToken: null,
            refreshToken: null
        }), n.onTransition((s)=>{
            s.matches({
                authentication: "signedIn"
            }) && e({
                isSuccess: !0,
                isError: !1,
                error: null,
                user: s.context.user,
                accessToken: s.context.accessToken.value,
                refreshToken: s.context.refreshToken.value
            }), s.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) && e({
                isSuccess: !1,
                isError: !0,
                error: s.context.errors.authentication || null,
                user: null,
                accessToken: null,
                refreshToken: null
            });
        });
    }), Ge = (n, e, r)=>new Promise((s)=>{
        const { changed: t, context: i } = n.send("SIGNIN_PASSWORD", {
            email: e,
            password: r
        });
        if (!t) return s({
            accessToken: i.accessToken.value,
            refreshToken: i.refreshToken.value,
            error: w,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            needsMfaOtp: !1,
            mfa: null,
            user: i.user
        });
        n.onTransition((l)=>{
            l.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? s({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                needsMfaOtp: !1,
                mfa: null,
                user: null
            }) : l.matches({
                authentication: {
                    signedOut: "needsMfa"
                }
            }) ? s({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !1,
                needsMfaOtp: !0,
                mfa: l.context.mfa,
                user: null
            }) : l.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) ? s({
                accessToken: null,
                refreshToken: null,
                error: l.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                needsMfaOtp: !1,
                mfa: null,
                user: null
            }) : l.matches({
                authentication: "signedIn"
            }) && s({
                accessToken: l.context.accessToken.value,
                refreshToken: l.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                needsMfaOtp: !1,
                mfa: null,
                user: l.context.user
            });
        });
    }), z = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send("PASSWORDLESS_EMAIL", {
            email: e,
            options: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1
        });
        n.onTransition((i)=>{
            i.matches("registration.incomplete.failed") ? s({
                error: i.context.errors.registration || null,
                isError: !0,
                isSuccess: !1
            }) : i.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) && s({
                error: null,
                isError: !1,
                isSuccess: !0
            });
        });
    }), He = (n, e)=>new Promise((r)=>{
        const { changed: s, context: t } = n.send({
            type: "SIGNIN_SECURITY_KEY_EMAIL",
            email: e
        });
        if (!s) return r({
            accessToken: t.accessToken.value,
            refreshToken: t.refreshToken.value,
            error: w,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            user: t.user
        });
        n.onTransition((i)=>{
            i.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? r({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                user: null
            }) : i.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) ? r({
                accessToken: null,
                refreshToken: null,
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                user: null
            }) : i.matches({
                authentication: "signedIn"
            }) && r({
                accessToken: i.context.accessToken.value,
                refreshToken: i.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                user: i.context.user
            });
        });
    });
function te(n) {
    return {
        error: n.message || "Something went wrong!",
        status: n.status || 1,
        message: n.message || "Something went wrong!"
    };
}
const $e = async (n, e)=>{
    var l, f;
    const r = (l = n.interpreter) == null ? void 0 : l.getSnapshot(), s = r == null ? void 0 : r.context.accessToken.value;
    let t;
    try {
        t = (await I(`${n.backendUrl}/elevate/webauthn`, {
            email: e
        }, s)).data;
    } catch (h) {
        return {
            error: te(h),
            isError: !0,
            isSuccess: !1,
            elevated: !1
        };
    }
    let i;
    try {
        i = await q(t);
    } catch (h) {
        return {
            error: te(h),
            isError: !0,
            isSuccess: !1,
            elevated: !1
        };
    }
    try {
        const { data: { session: h }, error: E } = await I(`${n.backendUrl}/elevate/webauthn/verify`, {
            email: e,
            credential: i
        }, s);
        return h && !E ? ((f = n.interpreter) == null || f.send({
            type: "SESSION_UPDATE",
            data: {
                session: h
            }
        }), {
            error: null,
            isError: !1,
            isSuccess: !0,
            elevated: !0
        }) : {
            error: E,
            isError: !0,
            isSuccess: !1,
            elevated: !1
        };
    } catch (h) {
        const { error: E } = h;
        return {
            error: E,
            isError: !0,
            isSuccess: !1,
            elevated: !1
        };
    }
}, We = (n, e, r)=>new Promise((s)=>{
        const { changed: t, context: i } = n.send("SIGNIN_MFA_TOTP", {
            otp: e,
            ticket: r
        });
        if (!t) return s({
            accessToken: i.accessToken.value,
            refreshToken: i.refreshToken.value,
            error: w,
            isError: !0,
            isSuccess: !1,
            user: i.user
        });
        n.onTransition((l)=>{
            l.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) ? s({
                accessToken: null,
                refreshToken: null,
                error: l.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                user: null
            }) : l.matches({
                authentication: "signedIn"
            }) && s({
                accessToken: l.context.accessToken.value,
                refreshToken: l.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                user: l.context.user
            });
        });
    }), Ye = (n, e)=>new Promise((r)=>{
        const { changed: s } = n.send("SIGNIN_PAT", {
            pat: e
        });
        s || r({
            isSuccess: !1,
            isError: !0,
            error: w,
            user: null,
            accessToken: null,
            refreshToken: null
        }), n.onTransition((t)=>{
            if (t.matches({
                authentication: {
                    signedOut: "failed"
                }
            })) return r({
                accessToken: null,
                refreshToken: null,
                user: null,
                error: t.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1
            });
            if (t.matches({
                authentication: "signedIn"
            })) return r({
                accessToken: t.context.accessToken.value,
                refreshToken: t.context.refreshToken.value,
                user: t.context.user,
                error: null,
                isError: !1,
                isSuccess: !0
            });
        });
    }), X = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send("PASSWORDLESS_SMS", {
            phoneNumber: e,
            options: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1,
            needsOtp: !1
        });
        n.onTransition((i)=>{
            i.matches("registration.incomplete.needsOtp") ? s({
                error: null,
                isError: !1,
                isSuccess: !1,
                needsOtp: !0
            }) : i.matches("registration.incomplete.failed") && s({
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsOtp: !1
            });
        });
    }), Fe = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send({
            type: "PASSWORDLESS_SMS_OTP",
            phoneNumber: e,
            otp: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1,
            user: null,
            accessToken: null,
            refreshToken: null
        });
        n.onTransition((i)=>{
            i.matches({
                authentication: "signedIn"
            }) ? s({
                error: null,
                isError: !1,
                isSuccess: !0,
                user: i.context.user,
                accessToken: i.context.accessToken.value,
                refreshToken: i.context.refreshToken.value
            }) : i.matches({
                registration: {
                    incomplete: "failed"
                }
            }) && s({
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                user: null,
                accessToken: null,
                refreshToken: null
            });
        });
    }), je = async (n, e)=>new Promise((r)=>{
        const { event: s } = n.send("SIGNOUT", {
            all: e
        });
        if (s.type !== "SIGNED_OUT") return r({
            isSuccess: !1,
            isError: !0,
            error: he
        });
        n.onTransition((t)=>{
            t.matches({
                authentication: {
                    signedOut: "success"
                }
            }) ? r({
                isSuccess: !0,
                isError: !1,
                error: null
            }) : t.matches("authentication.signedOut.failed") && r({
                isSuccess: !1,
                isError: !0,
                error: t.context.errors.signout || null
            });
        });
    }), Z = (n, e, r, s, t)=>new Promise((i)=>{
        const { changed: l, context: f } = n.send("SIGNUP_EMAIL_PASSWORD", {
            email: e,
            password: r,
            options: s,
            requestOptions: t
        });
        if (!l) return i({
            error: w,
            accessToken: f.accessToken.value,
            refreshToken: f.refreshToken.value,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            user: f.user
        });
        n.onTransition((h)=>{
            h.matches("registration.incomplete.failed") ? i({
                accessToken: null,
                refreshToken: null,
                error: h.context.errors.registration || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                user: null
            }) : h.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? i({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                user: null
            }) : h.matches({
                authentication: "signedIn",
                registration: "complete"
            }) && i({
                accessToken: h.context.accessToken.value,
                refreshToken: h.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                user: h.context.user
            });
        });
    }), qe = (n, e, r, s)=>new Promise((t)=>{
        const { changed: i, context: l } = n.send("SIGNUP_SECURITY_KEY", {
            email: e,
            options: r,
            requestOptions: s
        });
        if (!i) return t({
            error: w,
            accessToken: l.accessToken.value,
            refreshToken: l.refreshToken.value,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            user: l.user
        });
        n.onTransition((f)=>{
            f.matches("registration.incomplete.failed") ? t({
                accessToken: null,
                refreshToken: null,
                error: f.context.errors.registration || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                user: null
            }) : f.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? t({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                user: null
            }) : f.matches({
                authentication: "signedIn",
                registration: "complete"
            }) && t({
                accessToken: f.context.accessToken.value,
                refreshToken: f.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                user: f.context.user
            });
        });
    }), Be = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send("SIGNIN_EMAIL_OTP", {
            email: e,
            options: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1,
            needsOtp: !1
        });
        n.onTransition((i)=>{
            i.matches("registration.incomplete.needsOtp") ? s({
                error: null,
                isError: !1,
                isSuccess: !0,
                needsOtp: !0
            }) : i.matches("registration.incomplete.failed") && s({
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsOtp: !1
            });
        });
    }), Qe = (n, e, r)=>new Promise((s)=>{
        const { changed: t } = n.send({
            type: "VERIFY_EMAIL_OTP",
            email: e,
            otp: r
        });
        if (!t) return s({
            error: w,
            isError: !0,
            isSuccess: !1,
            user: null,
            accessToken: null,
            refreshToken: null
        });
        n.onTransition((i)=>{
            i.matches({
                authentication: "signedIn"
            }) ? s({
                error: null,
                isError: !1,
                isSuccess: !0,
                user: i.context.user,
                accessToken: i.context.accessToken.value,
                refreshToken: i.context.refreshToken.value
            }) : i.matches({
                registration: {
                    incomplete: "failed"
                }
            }) && s({
                error: i.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                user: null,
                accessToken: null,
                refreshToken: null
            });
        });
    }), ze = (n, { provider: e, idToken: r, nonce: s })=>new Promise((t)=>{
        const { changed: i } = n.send("SIGNIN_ID_TOKEN", {
            provider: e,
            idToken: r,
            ...s && {
                nonce: s
            }
        });
        i || t({
            isSuccess: !1,
            isError: !0,
            error: w,
            user: null,
            accessToken: null,
            refreshToken: null
        }), n.onTransition((l)=>{
            if (l.matches({
                authentication: {
                    signedOut: "failed"
                }
            })) return t({
                accessToken: null,
                refreshToken: null,
                user: null,
                error: l.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1
            });
            if (l.matches({
                authentication: "signedIn"
            })) return t({
                accessToken: l.context.accessToken.value,
                refreshToken: l.context.refreshToken.value,
                user: l.context.user,
                error: null,
                isError: !1,
                isSuccess: !0
            });
        });
    }), Xe = async ({ backendUrl: n, interpreter: e }, { provider: r, idToken: s, nonce: t })=>{
    try {
        return await I(`${n}/link/idtoken`, {
            provider: r,
            idToken: s,
            ...t && {
                nonce: t
            }
        }, e == null ? void 0 : e.getSnapshot().context.accessToken.value), {
            isError: !1,
            error: null,
            isSuccess: !0
        };
    } catch (i) {
        const { error: l } = i;
        return {
            isError: !0,
            error: l,
            isSuccess: !1
        };
    }
}, Ze = (n)=>new Promise((e)=>{
        const { changed: r, context: s } = n.send({
            type: "SIGNIN_SECURITY_KEY"
        });
        if (!r) return e({
            accessToken: s.accessToken.value,
            refreshToken: s.refreshToken.value,
            error: w,
            isError: !0,
            isSuccess: !1,
            needsEmailVerification: !1,
            user: s.user
        });
        n.onTransition((t)=>{
            t.matches({
                authentication: {
                    signedOut: "noErrors"
                },
                registration: {
                    incomplete: "needsEmailVerification"
                }
            }) ? e({
                accessToken: null,
                refreshToken: null,
                error: null,
                isError: !1,
                isSuccess: !1,
                needsEmailVerification: !0,
                user: null
            }) : t.matches({
                authentication: {
                    signedOut: "failed"
                }
            }) ? e({
                accessToken: null,
                refreshToken: null,
                error: t.context.errors.authentication || null,
                isError: !0,
                isSuccess: !1,
                needsEmailVerification: !1,
                user: null
            }) : t.matches({
                authentication: "signedIn"
            }) && e({
                accessToken: t.context.accessToken.value,
                refreshToken: t.context.refreshToken.value,
                error: null,
                isError: !1,
                isSuccess: !0,
                needsEmailVerification: !1,
                user: t.context.user
            });
        });
    }), Tr = async ({ backendUrl: n, interpreter: e }, { expiresAt: r, metadata: s })=>{
    try {
        const { data: t } = await I(`${n}/pat`, {
            expiresAt: r.toISOString(),
            metadata: s
        }, e == null ? void 0 : e.getSnapshot().context.accessToken.value);
        return {
            data: t ? {
                id: t.id || null,
                personalAccessToken: t.personalAccessToken || null
            } : null,
            isError: !1,
            error: null,
            isSuccess: !0
        };
    } catch (t) {
        const { error: i } = t;
        return {
            isError: !0,
            error: i,
            isSuccess: !1,
            data: null
        };
    }
};
class pr {
    constructor({ url: e, broadcastKey: r, autoRefreshToken: s = !0, autoSignIn: t = !0, clientStorage: i, clientStorageType: l, refreshIntervalTime: f, start: h = !0 }){
        var E;
        this.url = e, this._client = new se({
            backendUrl: e,
            clientUrl: ("TURBOPACK compile-time value", "undefined") != "undefined" && ((E = window.location) == null ? void 0 : E.origin) || "",
            broadcastKey: r,
            autoRefreshToken: s,
            autoSignIn: t,
            start: h,
            clientStorage: i,
            clientStorageType: l,
            refreshIntervalTime: f
        });
    }
    async signUp(e, r) {
        const s = await this.waitUntilReady();
        if ("securityKey" in e) {
            const { email: f, options: h } = e;
            return _(await qe(s, f, h, r));
        }
        const { email: t, password: i, options: l } = e;
        return _(await Z(s, t, i, l, r));
    }
    async connectProvider(e) {
        const s = (await this.waitUntilReady()).getSnapshot().context.accessToken.value, { provider: t, options: i } = e, l = L(`${this._client.backendUrl}/signin/provider/${t}`, R(this._client.clientUrl, {
            ...i,
            connect: s
        }));
        return M() && (window.location.href = l), {
            providerUrl: l
        };
    }
    async signInIdToken(e) {
        const r = await this.waitUntilReady(), s = await ze(r, e);
        return {
            ..._(s),
            mfa: null
        };
    }
    async linkIdToken(e) {
        return Xe(this._client, e);
    }
    async signIn(e) {
        const r = await this.waitUntilReady();
        if (!e) {
            const s = await Le(r);
            return {
                ..._(s),
                mfa: null
            };
        }
        if ("provider" in e) {
            const { provider: s, options: t } = e, i = L(`${this._client.backendUrl}/signin/provider/${s}`, R(this._client.clientUrl, t));
            return M() && (window.location.href = i), {
                providerUrl: i,
                provider: s,
                session: null,
                mfa: null,
                error: null
            };
        }
        if ("email" in e && "password" in e) {
            const s = await Ge(r, e.email, e.password);
            return s.needsEmailVerification ? {
                session: null,
                mfa: null,
                error: fe
            } : s.needsMfaOtp ? {
                session: null,
                mfa: s.mfa,
                error: null
            } : {
                ..._(s),
                mfa: null
            };
        }
        if ("email" in e && "securityKey" in e) {
            if (e.securityKey !== !0) throw Error("securityKey must be true");
            const s = await He(r, e.email);
            return {
                ..._(s),
                mfa: null
            };
        }
        if ("email" in e) {
            const { email: s, options: t } = e, { error: i } = await z(r, s, t);
            return {
                session: null,
                mfa: null,
                error: i
            };
        }
        if ("phoneNumber" in e && "otp" in e) {
            const s = await Fe(r, e.phoneNumber, e.otp);
            return {
                ..._(s),
                mfa: null
            };
        }
        if ("phoneNumber" in e) {
            const { error: s } = await X(r, e.phoneNumber, e.options);
            return {
                error: s,
                mfa: null,
                session: null
            };
        }
        if ("otp" in e) {
            const s = await We(r, e.otp, e.ticket);
            return {
                ..._(s),
                mfa: null
            };
        }
        return {
            error: me,
            mfa: null,
            session: null
        };
    }
    async signInPAT(e) {
        const r = await this.waitUntilReady(), s = await Ye(r, e);
        return _(s);
    }
    async signInEmailOTP(e, r) {
        const s = await this.waitUntilReady(), { error: t } = await Be(s, e, r);
        return {
            error: t,
            session: null,
            mfa: null
        };
    }
    async verifyEmailOTP(e, r) {
        const s = await this.waitUntilReady(), t = await Qe(s, e, r);
        return {
            ..._(t),
            mfa: null
        };
    }
    async signInSecurityKey() {
        const e = await this.waitUntilReady(), r = await Ze(e);
        return {
            ..._(r),
            mfa: null
        };
    }
    async signOut(e) {
        const r = await this.waitUntilReady(), { error: s } = await je(r, e == null ? void 0 : e.all);
        return {
            error: s
        };
    }
    async resetPassword({ email: e, options: r }) {
        const s = u.interpret(be(this._client)).start(), { error: t } = await Ke(s, e, r);
        return {
            error: t
        };
    }
    async changePassword({ newPassword: e, ticket: r }) {
        const s = u.interpret(Ne(this._client)).start(), { error: t } = await Ue(s, e, r);
        return {
            error: t
        };
    }
    async sendVerificationEmail({ email: e, options: r }) {
        const s = u.interpret(De(this._client)).start(), { error: t } = await Ve(s, e, r);
        return {
            error: t
        };
    }
    async changeEmail({ newEmail: e, options: r }) {
        const s = u.interpret(Oe(this._client)).start(), { error: t } = await Me(s, e, r);
        return {
            error: t
        };
    }
    async deanonymize(e) {
        const r = await this.waitUntilReady();
        if (e.signInMethod === "passwordless") {
            if (e.connection === "email") {
                const { error: s } = await z(r, e.email, e.options);
                return {
                    error: s
                };
            }
            if (e.connection === "sms") {
                const { error: s } = await X(r, e.phoneNumber, e.options);
                return {
                    error: s
                };
            }
        }
        if (e.signInMethod === "email-password") {
            const { error: s } = await Z(r, e.email, e.password, e.options);
            return {
                error: s
            };
        }
        throw Error("Unknown deanonymization method");
    }
    async addSecurityKey(e) {
        const { error: r, key: s } = await xe(this._client, e);
        return {
            error: r,
            key: s
        };
    }
    async elevateEmailSecurityKey(e) {
        if (!e) throw Error("A user email is required");
        return {
            ...await $e(this._client, e),
            mfa: null
        };
    }
    async createPAT(e, r) {
        return Tr(this._client, {
            expiresAt: e,
            metadata: r
        });
    }
    onTokenChanged(e) {
        return this._client.subscribe(()=>{
            var s;
            const r = (s = this._client.interpreter) == null ? void 0 : s.onTransition(({ event: t, context: i })=>{
                t.type === "TOKEN_CHANGED" && e(C(i));
            });
            return ()=>r == null ? void 0 : r.stop();
        });
    }
    onAuthStateChanged(e) {
        return this._client.subscribe(()=>{
            var s;
            const r = (s = this._client.interpreter) == null ? void 0 : s.onTransition(({ event: t, context: i })=>{
                (t.type === "SIGNED_IN" || t.type === "SIGNED_OUT") && e(t.type, C(i));
            });
            return ()=>r == null ? void 0 : r.stop();
        });
    }
    isAuthenticated() {
        var e;
        return !!((e = this._client.interpreter) != null && e.getSnapshot().matches({
            authentication: "signedIn"
        }));
    }
    async isAuthenticatedAsync() {
        return (await this.waitUntilReady()).getSnapshot().matches({
            authentication: "signedIn"
        });
    }
    getAuthenticationStatus() {
        var r;
        const e = ((r = this.client.interpreter) == null ? void 0 : r.getSnapshot().context.importTokenAttempts) || 0;
        return this.isReady() ? {
            isAuthenticated: this.isAuthenticated(),
            isLoading: !1,
            connectionAttempts: e
        } : {
            isAuthenticated: !1,
            isLoading: !0,
            connectionAttempts: e
        };
    }
    getAccessToken() {
        var e, r;
        return (r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot().context.accessToken.value) != null ? r : void 0;
    }
    getDecodedAccessToken() {
        const e = this.getAccessToken();
        return e ? er.jwtDecode(e) : null;
    }
    getHasuraClaims() {
        var e;
        return ((e = this.getDecodedAccessToken()) == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
    }
    getHasuraClaim(e) {
        var r;
        return ((r = this.getHasuraClaims()) == null ? void 0 : r[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
    }
    async refreshSession(e) {
        try {
            const r = await this.waitUntilReady();
            return new Promise((s)=>{
                const t = e || r.getSnapshot().context.refreshToken.value;
                if (!t) return s({
                    session: null,
                    error: ue
                });
                const { changed: i } = r.send("TRY_TOKEN", {
                    token: t
                });
                if (!i) return s({
                    session: null,
                    error: de
                });
                r.onTransition((l)=>{
                    l.matches({
                        token: {
                            idle: "error"
                        }
                    }) ? s({
                        session: null,
                        error: Ee
                    }) : l.event.type === "TOKEN_CHANGED" && s({
                        session: C(l.context),
                        error: null
                    });
                });
            });
        } catch (r) {
            return {
                session: null,
                error: r.message
            };
        }
    }
    getSession() {
        var e, r;
        return C((r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : r.context);
    }
    async initWithSession({ session: e }) {
        this.client.start({
            initialSession: e
        }), await this.waitUntilReady();
    }
    getUser() {
        var e, r, s;
        return ((s = (r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : r.context) == null ? void 0 : s.user) || null;
    }
    waitUntilReady() {
        const r = this._client.interpreter;
        if (!r) throw Error("Auth interpreter not set");
        return r.getSnapshot().hasTag("loading") ? new Promise((s, t)=>{
            let i = setTimeout(()=>t("The state machine is not yet ready after 15 seconds."), 15e3);
            r.onTransition((l)=>{
                if (!l.hasTag("loading")) return clearTimeout(i), s(r);
            });
        }) : Promise.resolve(r);
    }
    isReady() {
        var e, r;
        return !((r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) != null && r.hasTag("loading"));
    }
    get client() {
        return this._client;
    }
}
exports.AuthClient = se;
exports.AuthClientSSR = fr;
exports.AuthCookieClient = Ce;
exports.CodifiedError = O;
exports.EMAIL_NEEDS_VERIFICATION = fe;
exports.HasuraAuthClient = pr;
exports.INITIAL_MACHINE_CONTEXT = U;
exports.INVALID_EMAIL_ERROR = k;
exports.INVALID_MFA_CODE_ERROR = ae;
exports.INVALID_MFA_TICKET_ERROR = ce;
exports.INVALID_MFA_TYPE_ERROR = oe;
exports.INVALID_PASSWORD_ERROR = V;
exports.INVALID_PHONE_NUMBER_ERROR = j;
exports.INVALID_REFRESH_TOKEN = Ee;
exports.INVALID_SIGN_IN_METHOD = me;
exports.MIN_PASSWORD_LENGTH = ie;
exports.NETWORK_ERROR_CODE = J;
exports.NHOST_JWT_EXPIRES_AT_KEY = v;
exports.NHOST_REFRESH_TOKEN_ID_KEY = D;
exports.NHOST_REFRESH_TOKEN_KEY = N;
exports.NO_MFA_TICKET_ERROR = le;
exports.NO_REFRESH_TOKEN = ue;
exports.OTHER_ERROR_CODE = ee;
exports.REFRESH_TOKEN_MAX_ATTEMPTS = F;
exports.STATE_ERROR_CODE = b;
exports.TOKEN_REFRESHER_RUNNING_ERROR = de;
exports.TOKEN_REFRESH_MARGIN_SECONDS = Y;
exports.USER_ALREADY_SIGNED_IN = w;
exports.USER_NOT_ANONYMOUS = sr;
exports.USER_UNAUTHENTICATED = he;
exports.VALIDATION_ERROR_CODE = A;
exports.activateMfaPromise = mr;
exports.addSecurityKeyPromise = xe;
exports.changeEmailPromise = Me;
exports.changePasswordPromise = Ue;
exports.createAuthMachine = ve;
exports.createChangeEmailMachine = Oe;
exports.createChangePasswordMachine = Ne;
exports.createEnableMfaMachine = hr;
exports.createResetPasswordMachine = be;
exports.createSendVerificationEmailMachine = De;
exports.disableMfaPromise = gr;
exports.elevateEmailSecurityKeyPromise = $e;
exports.encodeQueryParameters = L;
exports.generateQrCodePromise = Er;
exports.getAuthenticationResult = _;
exports.getFetch = Ae;
exports.getParameterByName = x;
exports.getSession = C;
exports.isBrowser = M;
exports.isValidEmail = y;
exports.isValidPassword = G;
exports.isValidPhoneNumber = Q;
exports.isValidTicket = Pe;
exports.linkIdTokenPromise = Xe;
exports.localStorageGetter = Re;
exports.localStorageSetter = _e;
exports.postFetch = I;
exports.removeParameterFromWindow = B;
exports.resetPasswordPromise = Ke;
exports.rewriteRedirectTo = R;
exports.sendVerificationEmailPromise = Ve;
exports.signInAnonymousPromise = Le;
exports.signInEmailOTPPromise = Be;
exports.signInEmailPasswordPromise = Ge;
exports.signInEmailPasswordlessPromise = z;
exports.signInEmailSecurityKeyPromise = He;
exports.signInIdTokenPromise = ze;
exports.signInMfaTotpPromise = We;
exports.signInPATPromise = Ye;
exports.signInSecurityKeyPromise = Ze;
exports.signInSmsPasswordlessOtpPromise = Fe;
exports.signInSmsPasswordlessPromise = X;
exports.signOutPromise = je;
exports.signUpEmailPasswordPromise = Z;
exports.signUpEmailSecurityKeyPromise = qe;
exports.verifyEmailOTPPromise = Qe; //# sourceMappingURL=index.cjs.js.map
}),
"[project]/node_modules/.pnpm/@nhost+hasura-storage-js@2.9.0/node_modules/@nhost/hasura-storage-js/dist/index.cjs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var I = Object.defineProperty;
var x = (t, e, r)=>e in t ? I(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r;
var g = (t, e, r)=>x(t, typeof e != "symbol" ? e + "" : e, r);
Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const d = __turbopack_context__.r("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/index.js [app-ssr] (ecmascript)"), y = async (t, e, { accessToken: r, name: s, fileId: a, bucketId: i, adminSecret: o, onUploadProgress: l, headers: u = {} } = {})=>{
    var D;
    const p = {
        ...u
    };
    if (i && e.append("bucket-id", i), o && (p["x-hasura-admin-secret"] = o), r && (p.Authorization = `Bearer ${r}`), (s || a) && !e.has("metadata[]")) {
        const c = {};
        s && (c.name = s), a && (c.id = a), e.append("metadata[]", new Blob([
            JSON.stringify(c)
        ], {
            type: "application/json"
        }), "");
    }
    const O = `${t}/files`;
    if (typeof XMLHttpRequest == "undefined") try {
        const c = await fetch(O, {
            method: "POST",
            headers: p,
            body: e
        }), n = await c.json();
        return c.ok ? {
            fileMetadata: n,
            error: null
        } : {
            error: {
                status: c.status,
                message: ((D = n == null ? void 0 : n.error) == null ? void 0 : D.message) || c.statusText,
                error: c.statusText
            },
            fileMetadata: null
        };
    } catch (c) {
        return {
            error: {
                status: 0,
                message: c.message,
                error: c.message
            },
            fileMetadata: null
        };
    }
    return new Promise((c)=>{
        let n = new XMLHttpRequest;
        n.responseType = "json", n.onload = ()=>{
            var h, f, T, U, L, S, w, F;
            if (n.status < 200 || n.status >= 300) {
                const M = {
                    error: (L = (U = (f = (h = n.response) == null ? void 0 : h.error) == null ? void 0 : f.message) != null ? U : (T = n.response) == null ? void 0 : T.error) != null ? L : n.response,
                    message: (F = (w = (S = n.response) == null ? void 0 : S.error) == null ? void 0 : w.message) != null ? F : n.response,
                    status: n.status
                };
                return c({
                    fileMetadata: null,
                    error: M
                });
            }
            return c({
                fileMetadata: n.response,
                error: null
            });
        }, n.onerror = ()=>{
            const h = {
                error: n.statusText,
                message: n.statusText,
                status: n.status
            };
            return c({
                fileMetadata: null,
                error: h
            });
        }, l && n.upload.addEventListener("progress", l, !1), n.open("POST", O, !0), Object.entries(p).forEach(([h, f])=>{
            n.setRequestHeader(h, f);
        }), n.send(e);
    });
};
function A(t, e) {
    if (!e || Object.keys(e).length === 0) return t;
    const r = new URL(t), s = Object.entries(e).reduce((a, [i, o])=>({
            ...a,
            [i.charAt(0)]: o
        }), {});
    return Object.entries(s).forEach(([a, i])=>{
        i && r.searchParams.set(a, i);
    }), r.toString();
}
class _ {
    constructor({ url: e }){
        g(this, "url");
        g(this, "accessToken");
        g(this, "adminSecret");
        g(this, "headers", {});
        this.url = e;
    }
    async uploadFormData({ formData: e, bucketId: r, headers: s }) {
        const { error: a, fileMetadata: i } = await y(this.url, e, {
            bucketId: r,
            headers: {
                ...this.headers,
                ...s
            },
            accessToken: this.accessToken,
            adminSecret: this.adminSecret
        });
        return a ? {
            fileMetadata: null,
            error: a
        } : i && !("processedFiles" in i) ? {
            fileMetadata: {
                processedFiles: [
                    i
                ]
            },
            error: null
        } : {
            fileMetadata: i,
            error: null
        };
    }
    async uploadFile({ file: e, bucketId: r, id: s, name: a, headers: i }) {
        const o = new FormData;
        o.append("file[]", e), o.append("metadata[]", new Blob([
            JSON.stringify({
                id: s,
                name: a
            })
        ], {
            type: "application/json"
        }), "");
        const { error: l, fileMetadata: u } = await y(this.url, o, {
            accessToken: this.accessToken,
            adminSecret: this.adminSecret,
            bucketId: r,
            headers: {
                ...this.headers,
                ...i
            }
        });
        return l ? {
            fileMetadata: null,
            error: l
        } : u && "processedFiles" in u ? {
            fileMetadata: u.processedFiles[0],
            error: null
        } : {
            fileMetadata: u,
            error: null
        };
    }
    async downloadFile(e) {
        try {
            const { fileId: r, headers: s, ...a } = e, i = A(`${this.url}/files/${r}`, a), o = await fetch(i, {
                method: "GET",
                headers: {
                    ...this.generateAuthHeaders(),
                    ...this.headers,
                    ...s
                }
            });
            if (!o.ok) throw new Error(await o.text());
            return {
                file: await o.blob(),
                error: null
            };
        } catch (r) {
            return {
                file: null,
                error: r
            };
        }
    }
    async getPresignedUrl(e) {
        try {
            const { fileId: r, headers: s } = e, a = await fetch(`${this.url}/files/${r}/presignedurl`, {
                method: "GET",
                headers: {
                    ...this.generateAuthHeaders(),
                    ...this.headers,
                    ...s
                }
            });
            if (!a.ok) throw new Error(await a.text());
            return {
                presignedUrl: await a.json(),
                error: null
            };
        } catch (r) {
            return {
                presignedUrl: null,
                error: r
            };
        }
    }
    async delete(e) {
        try {
            const { fileId: r, headers: s } = e, a = await fetch(`${this.url}/files/${r}`, {
                method: "DELETE",
                headers: {
                    ...this.generateAuthHeaders(),
                    ...this.headers,
                    ...s
                }
            });
            if (!a.ok) throw new Error(await a.text());
            return {
                error: null
            };
        } catch (r) {
            return {
                error: r
            };
        }
    }
    setAccessToken(e) {
        return this.accessToken = e, this;
    }
    setAdminSecret(e) {
        return this.adminSecret = e, this;
    }
    getHeaders() {
        return this.headers;
    }
    setHeaders(e) {
        return e ? (this.headers = {
            ...this.headers,
            ...e
        }, this) : this;
    }
    unsetHeaders() {
        const e = this.headers["x-hasura-role"];
        return this.headers = e ? {
            "x-hasura-role": e
        } : {}, this;
    }
    generateAuthHeaders() {
        if (!(!this.adminSecret && !this.accessToken)) return this.adminSecret ? {
            "x-hasura-admin-secret": this.adminSecret
        } : {
            Authorization: `Bearer ${this.accessToken}`
        };
    }
}
class k {
    constructor({ url: e, adminSecret: r }){
        g(this, "url");
        g(this, "api");
        this.url = e, this.api = new _({
            url: e
        }), this.setAdminSecret(r);
    }
    async upload(e) {
        return "file" in e ? this.api.uploadFile(e) : this.api.uploadFormData(e);
    }
    getPublicUrl(e) {
        const { fileId: r, ...s } = e;
        return A(`${this.url}/files/${r}`, s);
    }
    async getPresignedUrl(e) {
        const { fileId: r, headers: s, ...a } = e, { presignedUrl: i, error: o } = await this.api.getPresignedUrl(e);
        if (o) return {
            presignedUrl: null,
            error: o
        };
        if (!i) return {
            presignedUrl: null,
            error: new Error("Invalid file id")
        };
        const l = A(i.url, a);
        return {
            presignedUrl: {
                ...i,
                url: l
            },
            error: null
        };
    }
    async download(e) {
        const { file: r, error: s } = await this.api.downloadFile(e);
        return s ? {
            file: null,
            error: s
        } : r ? {
            file: r,
            error: null
        } : {
            file: null,
            error: new Error("File does not exist")
        };
    }
    async delete(e) {
        const { error: r } = await this.api.delete(e);
        return r ? {
            error: r
        } : {
            error: null
        };
    }
    setAccessToken(e) {
        return this.api.setAccessToken(e), this;
    }
    setAdminSecret(e) {
        return this.api.setAdminSecret(e), this;
    }
    getHeaders() {
        return this.api.getHeaders();
    }
    setHeaders(e) {
        return this.api.setHeaders(e), this;
    }
    unsetHeaders() {
        return this.api.unsetHeaders(), this;
    }
}
const P = {
    progress: null,
    loaded: 0,
    error: null,
    bucketId: void 0,
    file: void 0,
    id: void 0
}, R = ()=>d.createMachine({
        predictableActionArguments: !0,
        schema: {
            context: {},
            events: {}
        },
        tsTypes: {},
        context: {
            ...P
        },
        initial: "idle",
        on: {
            DESTROY: {
                actions: "sendDestroy",
                target: "stopped"
            }
        },
        states: {
            idle: {
                on: {
                    ADD: {
                        actions: "addFile"
                    },
                    UPLOAD: {
                        cond: "hasFile",
                        target: "uploading"
                    }
                }
            },
            uploading: {
                entry: "resetProgress",
                on: {
                    UPLOAD_PROGRESS: {
                        actions: [
                            "incrementProgress",
                            "sendProgress"
                        ]
                    },
                    UPLOAD_DONE: "uploaded",
                    UPLOAD_ERROR: "error",
                    CANCEL: "idle"
                },
                invoke: {
                    src: "uploadFile"
                }
            },
            uploaded: {
                entry: [
                    "setFileMetadata",
                    "sendDone"
                ],
                on: {
                    ADD: {
                        actions: "addFile",
                        target: "idle"
                    },
                    UPLOAD: {
                        actions: "resetContext",
                        target: "uploading"
                    }
                }
            },
            error: {
                entry: [
                    "setError",
                    "sendError"
                ],
                on: {
                    ADD: {
                        actions: "addFile",
                        target: "idle"
                    },
                    UPLOAD: {
                        actions: "resetContext",
                        target: "uploading"
                    }
                }
            },
            stopped: {
                type: "final"
            }
        }
    }, {
        guards: {
            hasFile: (t, e)=>!!t.file || !!e.file
        },
        actions: {
            incrementProgress: d.assign({
                loaded: (t, { loaded: e })=>e,
                progress: (t, { progress: e })=>e
            }),
            setFileMetadata: d.assign({
                id: (t, { id: e })=>e,
                bucketId: (t, { bucketId: e })=>e,
                progress: (t)=>100
            }),
            setError: d.assign({
                error: (t, { error: e })=>e
            }),
            sendProgress: ()=>{},
            sendError: ()=>{},
            sendDestroy: ()=>{},
            sendDone: ()=>{},
            resetProgress: d.assign({
                progress: (t)=>null,
                loaded: (t)=>0
            }),
            resetContext: d.assign((t)=>P),
            addFile: d.assign({
                file: (t, { file: e })=>e,
                bucketId: (t, { bucketId: e })=>e,
                id: (t, { id: e })=>e
            })
        },
        services: {
            uploadFile: (t, e)=>(r)=>{
                    const s = e.file || t.file, a = new FormData;
                    a.append("file[]", s);
                    let i = 0;
                    return y(e.url, a, {
                        fileId: e.id || t.id,
                        bucketId: e.bucketId || t.bucketId,
                        accessToken: e.accessToken,
                        adminSecret: e.adminSecret,
                        name: e.name || s.name,
                        onUploadProgress: (o)=>{
                            const l = o.total ? Math.round(o.loaded * s.size / o.total) : 0, u = l - i;
                            i = l, r({
                                type: "UPLOAD_PROGRESS",
                                progress: o.total ? Math.round(l * 100 / o.total) : 0,
                                loaded: l,
                                additions: u
                            });
                        }
                    }).then(({ fileMetadata: o, error: l })=>{
                        if (l && r({
                            type: "UPLOAD_ERROR",
                            error: l
                        }), o && !("processedFiles" in o)) {
                            const { id: u, bucketId: p } = o;
                            r({
                                type: "UPLOAD_DONE",
                                id: u,
                                bucketId: p
                            });
                        }
                        if (o && "processedFiles" in o) {
                            const { id: u, bucketId: p } = o.processedFiles[0];
                            r({
                                type: "UPLOAD_DONE",
                                id: u,
                                bucketId: p
                            });
                        }
                    }), ()=>{};
                }
        }
    }), { pure: E, sendParent: m } = d.actions, b = ()=>d.createMachine({
        id: "files-list",
        schema: {
            context: {},
            events: {}
        },
        tsTypes: {},
        predictableActionArguments: !0,
        context: {
            progress: null,
            files: [],
            loaded: 0,
            total: 0
        },
        initial: "idle",
        on: {
            UPLOAD: {
                cond: "hasFileToDownload",
                actions: "addItem",
                target: "uploading"
            },
            ADD: {
                actions: "addItem"
            },
            REMOVE: {
                actions: "removeItem"
            }
        },
        states: {
            idle: {
                entry: [
                    "resetProgress",
                    "resetLoaded",
                    "resetTotal"
                ],
                on: {
                    CLEAR: {
                        actions: "clearList",
                        target: "idle"
                    }
                }
            },
            uploading: {
                entry: [
                    "upload",
                    "startProgress",
                    "resetLoaded",
                    "resetTotal"
                ],
                on: {
                    UPLOAD_PROGRESS: {
                        actions: [
                            "incrementProgress"
                        ]
                    },
                    UPLOAD_DONE: [
                        {
                            cond: "isAllUploaded",
                            target: "uploaded"
                        },
                        {
                            cond: "isAllUploadedOrError",
                            target: "error"
                        }
                    ],
                    UPLOAD_ERROR: [
                        {
                            cond: "isAllUploaded",
                            target: "uploaded"
                        },
                        {
                            cond: "isAllUploadedOrError",
                            target: "error"
                        }
                    ],
                    CANCEL: {
                        actions: "cancel",
                        target: "idle"
                    }
                }
            },
            uploaded: {
                entry: "setUploaded",
                on: {
                    CLEAR: {
                        actions: "clearList",
                        target: "idle"
                    }
                }
            },
            error: {
                on: {
                    CLEAR: {
                        actions: "clearList",
                        target: "idle"
                    }
                }
            }
        }
    }, {
        guards: {
            hasFileToDownload: (t, e)=>t.files.some((r)=>r.getSnapshot().matches("idle")) || !!e.files,
            isAllUploaded: (t)=>t.files.every((e)=>{
                    var r;
                    return (r = e.getSnapshot()) == null ? void 0 : r.matches("uploaded");
                }),
            isAllUploadedOrError: (t)=>t.files.every((e)=>{
                    const r = e.getSnapshot();
                    return (r == null ? void 0 : r.matches("error")) || (r == null ? void 0 : r.matches("uploaded"));
                })
        },
        actions: {
            incrementProgress: d.assign((t, e)=>{
                const r = t.loaded + e.additions, s = Math.round(r * 100 / t.total);
                return {
                    ...t,
                    loaded: r,
                    progress: s
                };
            }),
            setUploaded: d.assign({
                progress: (t)=>100,
                loaded: ({ files: t })=>t.map((e)=>e.getSnapshot()).filter((e)=>e.matches("uploaded")).reduce((e, r)=>{
                        var s;
                        return e + ((s = r.context.file) == null ? void 0 : s.size);
                    }, 0)
            }),
            resetTotal: d.assign({
                total: ({ files: t })=>t.map((e)=>e.getSnapshot()).filter((e)=>!e.matches("uploaded")).reduce((e, r)=>{
                        var s;
                        return e + ((s = r.context.file) == null ? void 0 : s.size);
                    }, 0)
            }),
            resetLoaded: d.assign({
                loaded: (t)=>0
            }),
            startProgress: d.assign({
                progress: (t)=>0
            }),
            resetProgress: d.assign({
                progress: (t)=>null
            }),
            addItem: d.assign((t, { files: e, bucketId: r })=>{
                const s = e ? Array.isArray(e) ? e : "item" in e ? Array.from(e) : [
                    e
                ] : [], a = t.total + s.reduce((o, l)=>o + l.size, 0), i = Math.round(t.loaded * 100 / a);
                return {
                    files: [
                        ...t.files,
                        ...s.map((o)=>d.spawn(R().withConfig({
                                actions: {
                                    sendProgress: m((l, { additions: u })=>({
                                            type: "UPLOAD_PROGRESS",
                                            additions: u
                                        })),
                                    sendDone: m("UPLOAD_DONE"),
                                    sendError: m("UPLOAD_ERROR"),
                                    sendDestroy: m("REMOVE")
                                }
                            }).withContext({
                                ...P,
                                file: o,
                                bucketId: r
                            }), {
                                sync: !0
                            }))
                    ],
                    total: a,
                    loaded: t.loaded,
                    progress: i
                };
            }),
            removeItem: d.assign({
                files: (t)=>t.files.filter((e)=>{
                        var s, a;
                        const r = (s = e.getSnapshot()) == null ? void 0 : s.matches("stopped");
                        return r && ((a = e.stop) == null || a.call(e)), !r;
                    })
            }),
            clearList: E((t)=>t.files.map((e)=>d.send({
                        type: "DESTROY"
                    }, {
                        to: e.id
                    }))),
            upload: E((t, e)=>t.files.map((r)=>d.send(e, {
                        to: r.id
                    }))),
            cancel: E((t)=>t.files.map((e)=>d.send({
                        type: "CANCEL"
                    }, {
                        to: e.id
                    })))
        }
    }), H = async (t, e)=>new Promise((r)=>{
        e.send({
            type: "UPLOAD",
            ...t
        }), e.subscribe((s)=>{
            var a;
            s.matches("error") ? r({
                error: s.context.error,
                isError: !0,
                isUploaded: !1
            }) : s.matches("uploaded") && r({
                error: null,
                isError: !1,
                isUploaded: !0,
                id: s.context.id,
                bucketId: s.context.id,
                name: (a = s.context.file) == null ? void 0 : a.name
            });
        });
    }), C = async (t, e)=>new Promise((r)=>{
        e.send({
            type: "UPLOAD",
            ...t,
            files: t.files
        }), e.onTransition((s)=>{
            s.matches("error") ? r({
                errors: s.context.files.filter((a)=>{
                    var i;
                    return (i = a.getSnapshot()) == null ? void 0 : i.context.error;
                }),
                isError: !0,
                files: []
            }) : s.matches("uploaded") && r({
                errors: [],
                isError: !1,
                files: s.context.files
            });
        });
    });
exports.HasuraStorageApi = _;
exports.HasuraStorageClient = k;
exports.INITIAL_FILE_CONTEXT = P;
exports.appendImageTransformationParameters = A;
exports.createFileUploadMachine = R;
exports.createMultipleFilesUploadMachine = b;
exports.uploadFilePromise = H;
exports.uploadMultipleFilesPromise = C; //# sourceMappingURL=index.cjs.js.map
}),
"[project]/node_modules/.pnpm/unfetch@4.2.0/node_modules/unfetch/dist/unfetch.module.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function __TURBOPACK__default__export__(e, n) {
    return n = n || {}, new Promise(function(t, r) {
        var s = new XMLHttpRequest, o = [], u = [], i = {}, a = function() {
            return {
                ok: 2 == (s.status / 100 | 0),
                statusText: s.statusText,
                status: s.status,
                url: s.responseURL,
                text: function() {
                    return Promise.resolve(s.responseText);
                },
                json: function() {
                    return Promise.resolve(s.responseText).then(JSON.parse);
                },
                blob: function() {
                    return Promise.resolve(new Blob([
                        s.response
                    ]));
                },
                clone: a,
                headers: {
                    keys: function() {
                        return o;
                    },
                    entries: function() {
                        return u;
                    },
                    get: function(e) {
                        return i[e.toLowerCase()];
                    },
                    has: function(e) {
                        return e.toLowerCase() in i;
                    }
                }
            };
        };
        for(var l in s.open(n.method || "get", e, !0), s.onload = function() {
            s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e, n, t) {
                o.push(n = n.toLowerCase()), u.push([
                    n,
                    t
                ]), i[n] = i[n] ? i[n] + "," + t : t;
            }), t(a());
        }, s.onerror = r, s.withCredentials = "include" == n.credentials, n.headers)s.setRequestHeader(l, n.headers[l]);
        s.send(n.body || null);
    });
} //# sourceMappingURL=unfetch.module.js.map
}),
"[project]/node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

function r(m) {
    return m && m.default || m;
}
module.exports = /*TURBOPACK member replacement*/ __turbopack_context__.g.fetch = /*TURBOPACK member replacement*/ __turbopack_context__.g.fetch || (typeof process == 'undefined' ? r(__turbopack_context__.r("[project]/node_modules/.pnpm/unfetch@4.2.0/node_modules/unfetch/dist/unfetch.module.js [app-ssr] (ecmascript)")) : function(url, opts) {
    return r(__turbopack_context__.r("[project]/node_modules/.pnpm/node-fetch@2.7.0/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)"))(String(url).replace(/^\/\//g, 'https://'), opts);
});
}),
"[project]/node_modules/.pnpm/@nhost+graphql-js@0.3.0_graphql@16.8.1/node_modules/@nhost/graphql-js/dist/index.cjs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const T = __turbopack_context__.r("[project]/node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js [app-ssr] (ecmascript)"), c = __turbopack_context__.r("[project]/node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/index.mjs [app-ssr] (ecmascript)"), m = __turbopack_context__.r("[project]/node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/cjs/index.js [app-ssr] (ecmascript)");
function g(r, e, s) {
    return r.document ? r : {
        document: r,
        variables: e,
        config: s
    };
}
function l(r) {
    var n;
    let e;
    const s = r.definitions.filter((t)=>t.kind === "OperationDefinition");
    return s.length === 1 && (e = (n = s[0].name) == null ? void 0 : n.value), e;
}
function k(r) {
    if (typeof r == "string") {
        let s;
        try {
            const n = c.parse(r);
            s = l(n);
        } catch  {}
        return {
            query: r,
            operationName: s
        };
    }
    const e = l(r);
    return {
        query: c.print(r),
        operationName: e
    };
}
class y {
    constructor(e){
        this.headers = {}, this.isAccessTokenValidOrNull = ()=>{
            if (!this.accessToken) return !0;
            try {
                const t = m.jwtDecode(this.accessToken);
                return t.exp != null && t.exp * 1e3 > Date.now();
            } catch (t) {
                return console.error("Error decoding token:", t), !1;
            }
        }, this.awaitForValidAccessTokenOrNull = async ()=>{
            if (this.isAccessTokenValidOrNull()) return !0;
            const t = ()=>this.isAccessTokenValidOrNull() ? Promise.resolve(!0) : new Promise((i)=>{
                    setTimeout(()=>t().then(i), 100);
                });
            return t();
        };
        const { url: s, adminSecret: n } = e;
        this._url = s, this.accessToken = null, this.adminSecret = n;
    }
    async request(e, ...s) {
        const [n, t] = s, i = g(e, n, t), { headers: h, ...d } = t || {}, { query: p, operationName: f } = k(i.document);
        typeof process != "undefined" && !process.env.TEST_MODE && await this.awaitForValidAccessTokenOrNull();
        try {
            const a = await T(this.httpUrl, {
                method: "POST",
                body: JSON.stringify({
                    operationName: f,
                    query: p,
                    variables: n
                }),
                headers: {
                    "Content-Type": "application/json",
                    ...this.generateAccessTokenHeaders(),
                    ...this.headers,
                    ...h
                },
                ...d
            });
            if (!a.ok) return {
                data: null,
                error: {
                    error: a.statusText,
                    message: a.statusText,
                    status: a.status
                }
            };
            const { data: o, errors: u } = await a.json();
            return u ? {
                data: null,
                error: u
            } : typeof o != "object" || Array.isArray(o) || o === null ? {
                data: null,
                error: {
                    error: "invalid-response",
                    message: "incorrect response data from GraphQL server",
                    status: 0
                }
            } : {
                data: o,
                error: null
            };
        } catch (a) {
            const o = a;
            return {
                data: null,
                error: {
                    message: o.message,
                    status: o.name === "AbortError" ? 0 : 500,
                    error: o.name === "AbortError" ? "abort-error" : "unknown"
                }
            };
        }
    }
    get httpUrl() {
        return this._url;
    }
    get wsUrl() {
        return this._url.replace(/^(http)(s?):\/\//, "ws$2://");
    }
    get url() {
        return this._url;
    }
    getUrl() {
        return this._url;
    }
    setAccessToken(e) {
        if (!e) {
            this.accessToken = null;
            return;
        }
        this.accessToken = e;
    }
    getHeaders() {
        return this.headers;
    }
    setHeaders(e) {
        e && (this.headers = {
            ...this.headers,
            ...e
        });
    }
    unsetHeaders() {
        const e = this.headers["x-hasura-role"];
        this.headers = e ? {
            "x-hasura-role": e
        } : {};
    }
    generateAccessTokenHeaders() {
        return this.adminSecret ? {
            "x-hasura-admin-secret": this.adminSecret
        } : this.accessToken ? {
            Authorization: `Bearer ${this.accessToken}`
        } : {};
    }
}
exports.NhostGraphqlClient = y; //# sourceMappingURL=index.cjs.js.map
}),
"[project]/node_modules/.pnpm/@nhost+nhost-js@3.3.1_graphql@16.8.1/node_modules/@nhost/nhost-js/dist/index.cjs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var k = Object.defineProperty;
var q = (t, e, r)=>e in t ? k(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r;
var a = (t, e, r)=>q(t, typeof e != "symbol" ? e + "" : e, r);
Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const p = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+hasura-auth-js@2.12.0/node_modules/@nhost/hasura-auth-js/dist/index.cjs.js [app-ssr] (ecmascript)"), T = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+hasura-storage-js@2.9.0/node_modules/@nhost/hasura-storage-js/dist/index.cjs.js [app-ssr] (ecmascript)"), y = __turbopack_context__.r("[project]/node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js [app-ssr] (ecmascript)"), H = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+graphql-js@0.3.0_graphql@16.8.1/node_modules/@nhost/graphql-js/dist/index.cjs.js [app-ssr] (ecmascript)"), v = /^((?<protocol>http[s]?):\/\/)?(?<host>(localhost|local))(:(?<port>(\d+|__\w+__)))?$/;
function f(t, e) {
    const { subdomain: r, region: n } = t;
    if (!r) throw new Error("A `subdomain` must be set.");
    const u = r.match(v);
    if (u != null && u.groups) {
        const { protocol: h, host: i, port: l } = u.groups, s = E(e);
        return s || (i === "localhost" ? (console.warn('The `subdomain` is set to "localhost". Support for this will be removed in a future release. Please use "local" instead.'), `${h || "http"}://localhost:${l || 1337}/v1/${e}`) : l ? `${h || "https"}://local.${e}.local.nhost.run:${l}/v1` : `${h || "https"}://local.${e}.local.nhost.run/v1`);
    }
    if (!n) throw new Error('`region` must be set when using a `subdomain` other than "local".');
    return `https://${r}.${e}.${n}.nhost.run/v1`;
}
function U() {
    return ("TURBOPACK compile-time value", "undefined") != "undefined";
}
function $() {
    return typeof process != "undefined" && process.env;
}
function E(t) {
    return U() || !$() ? null : process.env[`NHOST_${t.toUpperCase()}_URL`];
}
function O(t, e) {
    const n = e.startsWith("/") ? e : `/${e}`;
    return t + n;
}
function b(t) {
    const e = "subdomain" in t ? f(t, "auth") : t.authUrl, { subdomain: r, region: n } = t;
    if (!e) throw new Error("Please provide `subdomain` or `authUrl`.");
    return new p.HasuraAuthClient({
        url: e,
        broadcastKey: `${r}${n != null ? n : "local"}`,
        ...t
    });
}
function w(t) {
    const e = "subdomain" in t ? f(t, "functions") : t.functionsUrl;
    if (!e) throw new Error("Please provide `subdomain` or `functionsUrl`.");
    return new m({
        url: e,
        ...t
    });
}
class m {
    constructor(e){
        a(this, "url");
        a(this, "accessToken");
        a(this, "adminSecret");
        a(this, "headers", {});
        const { url: r, adminSecret: n } = e;
        this.url = r, this.accessToken = null, this.adminSecret = n;
    }
    async call(e, r, n) {
        var i, l;
        const u = {
            "Content-Type": "application/json",
            ...this.generateAccessTokenHeaders(),
            ...n == null ? void 0 : n.headers,
            ...this.headers
        }, h = O(this.url, e);
        try {
            const s = await y(h, {
                body: r ? JSON.stringify(r) : null,
                headers: u,
                method: "POST"
            });
            if (!s.ok) {
                let c;
                return (i = s.headers.get("content-type")) != null && i.includes("application/json") ? c = await s.json() : c = await s.text(), {
                    res: null,
                    error: {
                        message: c,
                        error: s.statusText,
                        status: s.status
                    }
                };
            }
            let o;
            return (l = s.headers.get("content-type")) != null && l.includes("application/json") ? o = await s.json() : o = await s.text(), {
                res: {
                    data: o,
                    status: s.status,
                    statusText: s.statusText
                },
                error: null
            };
        } catch (s) {
            const o = s;
            return {
                res: null,
                error: {
                    message: o.message,
                    status: o.name === "AbortError" ? 0 : 500,
                    error: o.name === "AbortError" ? "abort-error" : "unknown"
                }
            };
        }
    }
    setAccessToken(e) {
        if (!e) {
            this.accessToken = null;
            return;
        }
        this.accessToken = e;
    }
    getHeaders() {
        return this.headers;
    }
    setHeaders(e) {
        e && (this.headers = {
            ...this.headers,
            ...e
        });
    }
    unsetHeaders() {
        const e = this.headers["x-hasura-role"];
        this.headers = e ? {
            "x-hasura-role": e
        } : {};
    }
    generateAccessTokenHeaders() {
        return this.adminSecret ? {
            "x-hasura-admin-secret": this.adminSecret
        } : this.accessToken ? {
            Authorization: `Bearer ${this.accessToken}`
        } : {};
    }
}
function S(t) {
    const e = "subdomain" in t ? f(t, "graphql") : t.graphqlUrl;
    if (!e) throw new Error("Please provide `subdomain` or `graphqlUrl`.");
    return new H.NhostGraphqlClient({
        url: e,
        ...t
    });
}
function A(t) {
    const e = "subdomain" in t ? f(t, "storage") : t.storageUrl;
    if (!e) throw new Error("Please provide `subdomain` or `storageUrl`.");
    return new T.HasuraStorageClient({
        url: e,
        ...t
    });
}
const _ = (t)=>new C(t);
class C {
    constructor({ refreshIntervalTime: e, clientStorage: r, clientStorageType: n, autoRefreshToken: u, autoSignIn: h, adminSecret: i, devTools: l, start: s = !0, ...o }){
        a(this, "auth");
        a(this, "storage");
        a(this, "functions");
        a(this, "graphql");
        a(this, "_adminSecret");
        a(this, "devTools");
        this.auth = b({
            refreshIntervalTime: e,
            clientStorage: r,
            clientStorageType: n,
            autoRefreshToken: u,
            autoSignIn: h,
            start: s,
            ...o
        }), this.storage = A({
            adminSecret: i,
            ...o
        }), this.functions = w({
            adminSecret: i,
            ...o
        }), this.graphql = S({
            adminSecret: i,
            ...o
        }), this.auth.onAuthStateChanged((c, d)=>{
            if (c === "SIGNED_OUT") {
                this.storage.setAccessToken(void 0), this.functions.setAccessToken(void 0), this.graphql.setAccessToken(void 0);
                return;
            }
            const g = d == null ? void 0 : d.accessToken;
            this.storage.setAccessToken(g), this.functions.setAccessToken(g), this.graphql.setAccessToken(g);
        }), this.auth.onTokenChanged((c)=>{
            const d = c == null ? void 0 : c.accessToken;
            this.storage.setAccessToken(d), this.functions.setAccessToken(d), this.graphql.setAccessToken(d);
        }), this._adminSecret = i, this.devTools = l;
    }
    get adminSecret() {
        return this._adminSecret;
    }
    set adminSecret(e) {
        this._adminSecret = e, this.storage.setAdminSecret(e);
    }
    setRole(e) {
        this.graphql.setHeaders({
            "x-hasura-role": e
        }), this.storage.setHeaders({
            "x-hasura-role": e
        }), this.functions.setHeaders({
            "x-hasura-role": e
        });
    }
    unsetRole() {
        this.graphql.setHeaders((({ "x-hasura-role": e, ...r })=>r)(this.graphql.getHeaders())), this.storage.setHeaders((({ "x-hasura-role": e, ...r })=>r)(this.storage.getHeaders())), this.functions.setHeaders((({ "x-hasura-role": e, ...r })=>r)(this.functions.getHeaders()));
    }
}
exports.NhostClient = C;
exports.NhostFunctionsClient = m;
exports.createAuthClient = b;
exports.createFunctionsClient = w;
exports.createGraphqlClient = S;
exports.createNhostClient = _;
exports.createStorageClient = A;
exports.urlFromSubdomain = f;
Object.keys(p).forEach((t)=>{
    t !== "default" && !Object.prototype.hasOwnProperty.call(exports, t) && Object.defineProperty(exports, t, {
        enumerable: !0,
        get: ()=>p[t]
    });
});
Object.keys(T).forEach((t)=>{
    t !== "default" && !Object.prototype.hasOwnProperty.call(exports, t) && Object.defineProperty(exports, t, {
        enumerable: !0,
        get: ()=>T[t]
    });
}); //# sourceMappingURL=index.cjs.js.map
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
;
;
;
;
;
;
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useConstant.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>useConstant
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
function useConstant(fn) {
    var ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"]();
    if (!ref.current) {
        ref.current = {
            v: fn()
        };
    }
    return ref.current.v;
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useInterpret.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useIdleInterpreter",
    ()=>useIdleInterpreter,
    "useInterpret",
    ()=>useInterpret
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$isomorphic$2d$layout$2d$effect$40$1$2e$2$2e$1_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$isomorphic$2d$layout$2d$effect$2f$dist$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-isomorphic-layout-effect@1.2.1_@types+react@19.2.7_react@19.2.3/node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/interpreter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/State.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useConstant.js [app-ssr] (ecmascript)");
var __assign = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
var __read = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
;
;
;
;
function useIdleInterpreter(getMachine, options) {
    var machine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        return typeof getMachine === 'function' ? getMachine() : getMachine;
    });
    if (("TURBOPACK compile-time value", "development") !== 'production' && typeof getMachine !== 'function') {
        var _a = __read((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(machine), 1), initialMachine = _a[0];
        if (getMachine !== initialMachine) {
            console.warn('Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\n' + 'Please make sure that you pass the same Machine as argument each time.');
        }
    }
    var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, [
        "context",
        "guards",
        "actions",
        "activities",
        "services",
        "delays",
        "state"
    ]);
    var service = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        var machineConfig = {
            context: context,
            guards: guards,
            actions: actions,
            activities: activities,
            services: services,
            delays: delays
        };
        var machineWithConfig = machine.withConfig(machineConfig, function() {
            return __assign(__assign({}, machine.context), context);
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["interpret"])(machineWithConfig, interpreterOptions);
    });
    // Make sure options are kept updated when they change.
    // This mutation assignment is safe because the service instance is only used
    // in one place -- this hook's caller.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$isomorphic$2d$layout$2d$effect$40$1$2e$2$2e$1_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$isomorphic$2d$layout$2d$effect$2f$dist$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        Object.assign(service.machine.options.actions, actions);
        Object.assign(service.machine.options.guards, guards);
        Object.assign(service.machine.options.activities, activities);
        Object.assign(service.machine.options.services, services);
        Object.assign(service.machine.options.delays, delays);
    }, [
        actions,
        guards,
        activities,
        services,
        delays
    ]);
    return service;
}
function useInterpret(getMachine) {
    var _a = [];
    for(var _i = 1; _i < arguments.length; _i++){
        _a[_i - 1] = arguments[_i];
    }
    var _b = __read(_a, 2), _c = _b[0], options = _c === void 0 ? {} : _c, observerOrListener = _b[1];
    var service = useIdleInterpreter(getMachine, options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        if (!observerOrListener) {
            return;
        }
        var sub = service.subscribe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toObserver"])(observerOrListener));
        return function() {
            sub.unsubscribe();
        };
    }, [
        observerOrListener
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        var rehydratedState = options.state;
        service.start(rehydratedState ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].create(rehydratedState) : undefined);
        return function() {
            service.stop();
            service.status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpreterStatus"].NotStarted;
        };
    }, []);
    return service;
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getServiceSnapshot",
    ()=>getServiceSnapshot,
    "isInterpreterStateEqual",
    ()=>isInterpreterStateEqual,
    "isService",
    ()=>isService,
    "partition",
    ()=>partition,
    "shallowEqual",
    ()=>shallowEqual
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/interpreter.js [app-ssr] (ecmascript)");
var __read = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __values = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
;
function partition(items, predicate) {
    var e_1, _a;
    var _b = __read([
        [],
        []
    ], 2), truthy = _b[0], falsy = _b[1];
    try {
        for(var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()){
            var item = items_1_1.value;
            if (predicate(item)) {
                truthy.push(item);
            } else {
                falsy.push(item);
            }
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return [
        truthy,
        falsy
    ];
}
function getServiceSnapshot(service) {
    return service.status !== 0 ? service.getSnapshot() : service.machine.initialState;
}
// From https://github.com/reduxjs/react-redux/blob/master/src/utils/shallowEqual.ts
function is(x, y) {
    if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
        return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for(var i = 0; i < keysA.length; i++){
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
        }
    }
    return true;
}
function isService(actor) {
    return 'state' in actor && 'machine' in actor;
}
function isInterpreterStateEqual(service, prevState, nextState) {
    if (service.status === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpreterStatus"].NotStarted) {
        return true;
    }
    // Only change the current state if:
    // - the incoming state is the "live" initial state (since it might have new actors)
    // - OR the incoming state actually changed.
    //
    // The "live" initial state will have .changed === undefined.
    var initialStateChanged = nextState.changed === undefined && (Object.keys(nextState.children).length > 0 || typeof prevState.changed === 'boolean');
    return !(nextState.changed || initialStateChanged);
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useMachine.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useMachine",
    ()=>useMachine
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$6$2e$0_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/shim/with-selector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/interpreter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/State.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useInterpret.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)");
var __read = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
;
;
;
;
;
function identity(a) {
    return a;
}
function useMachine(getMachine) {
    var _a = [];
    for(var _i = 1; _i < arguments.length; _i++){
        _a[_i - 1] = arguments[_i];
    }
    var _b = __read(_a, 1), _c = _b[0], options = _c === void 0 ? {} : _c;
    // using `useIdleInterpreter` allows us to subscribe to the service *before* we start it
    // so we don't miss any notifications
    var service = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useIdleInterpreter"])(getMachine, options);
    var getSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function() {
        if (service.status === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpreterStatus"].NotStarted) {
            return options.state ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].create(options.state) : service.machine.initialState;
        }
        return service.getSnapshot();
    }, [
        service
    ]);
    var isEqual = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(prevState, nextState) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInterpreterStateEqual"])(service, prevState, nextState);
    }, [
        service
    ]);
    var subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(handleStoreChange) {
        var unsubscribe = service.subscribe(handleStoreChange).unsubscribe;
        return unsubscribe;
    }, [
        service
    ]);
    var storeSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$6$2e$0_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscribe, getSnapshot, getSnapshot, identity, isEqual);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        var rehydratedState = options.state;
        service.start(rehydratedState ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$State$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["State"].create(rehydratedState) : undefined);
        return function() {
            service.stop();
            service.status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$interpreter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InterpreterStatus"].NotStarted;
        };
    }, []);
    return [
        storeSnapshot,
        service.send,
        service
    ];
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useActor.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isActorWithState",
    ()=>isActorWithState,
    "useActor",
    ()=>useActor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$isomorphic$2d$layout$2d$effect$40$1$2e$2$2e$1_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$isomorphic$2d$layout$2d$effect$2f$dist$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-isomorphic-layout-effect@1.2.1_@types+react@19.2.7_react@19.2.3/node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useConstant.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$6$2e$0_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/shim/with-selector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
function identity(a) {
    return a;
}
function isActorWithState(actorRef) {
    return 'state' in actorRef;
}
function isDeferredActor(actorRef) {
    return 'deferred' in actorRef;
}
function defaultGetSnapshot(actorRef) {
    return 'getSnapshot' in actorRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isService"])(actorRef) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getServiceSnapshot"])(actorRef) : actorRef.getSnapshot() : isActorWithState(actorRef) ? actorRef.state : undefined;
}
function useActor(actorRef, getSnapshot) {
    if (getSnapshot === void 0) {
        getSnapshot = defaultGetSnapshot;
    }
    var actorRefRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(actorRef);
    var deferredEventsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])([]);
    var subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(handleStoreChange) {
        var unsubscribe = actorRef.subscribe(handleStoreChange).unsubscribe;
        return unsubscribe;
    }, [
        actorRef
    ]);
    var boundGetSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function() {
        return getSnapshot(actorRef);
    }, [
        actorRef,
        getSnapshot
    ]);
    var isEqual = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(prevState, nextState) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isService"])(actorRef)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isInterpreterStateEqual"])(actorRef, prevState, nextState);
        }
        return prevState === nextState;
    }, [
        actorRef
    ]);
    var storeSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$6$2e$0_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscribe, boundGetSnapshot, boundGetSnapshot, identity, isEqual);
    var send = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        return function() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++){
                args[_i] = arguments[_i];
            }
            var event = args[0];
            if (("TURBOPACK compile-time value", "development") !== 'production' && args.length > 1) {
                console.warn("Unexpected payload: ".concat(JSON.stringify(args[1]), ". Only a single event object can be sent to actor send() functions."));
            }
            var currentActorRef = actorRefRef.current;
            // If the previous actor is a deferred actor,
            // queue the events so that they can be replayed
            // on the non-deferred actor.
            if (isDeferredActor(currentActorRef) && currentActorRef.deferred) {
                deferredEventsRef.current.push(event);
            } else {
                currentActorRef.send(event);
            }
        };
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$isomorphic$2d$layout$2d$effect$40$1$2e$2$2e$1_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$isomorphic$2d$layout$2d$effect$2f$dist$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        actorRefRef.current = actorRef;
        // Dequeue deferred events from the previous deferred actorRef
        while(deferredEventsRef.current.length > 0){
            var deferredEvent = deferredEventsRef.current.shift();
            actorRef.send(deferredEvent);
        }
    }, [
        actorRef
    ]);
    return [
        storeSnapshot,
        send
    ];
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useSelector.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useSelector",
    ()=>useSelector
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$6$2e$0_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/shim/with-selector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useActor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)");
;
;
;
;
var defaultCompare = function(a, b) {
    return a === b;
};
var defaultGetSnapshot = function(a, initialStateCacheRef) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isService"])(a)) {
        // A status of 0 = interpreter not started
        if (a.status === 0 && initialStateCacheRef.current) {
            return initialStateCacheRef.current;
        }
        var snapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getServiceSnapshot"])(a);
        initialStateCacheRef.current = a.status === 0 ? snapshot : null;
        return snapshot;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isActorWithState"])(a) ? a.state : undefined;
};
function useSelector(actor, selector, compare, getSnapshot) {
    if (compare === void 0) {
        compare = defaultCompare;
    }
    var initialStateCacheRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"])(null);
    var subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function(handleStoreChange) {
        var unsubscribe = actor.subscribe(handleStoreChange).unsubscribe;
        return unsubscribe;
    }, [
        actor
    ]);
    var boundGetSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useCallback"])(function() {
        if (getSnapshot) {
            return getSnapshot(actor);
        }
        return defaultGetSnapshot(actor, initialStateCacheRef);
    }, [
        actor,
        getSnapshot
    ]);
    var selectedSnapshot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$use$2d$sync$2d$external$2d$store$40$1$2e$6$2e$0_react$40$19$2e$2$2e$3$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscribe, boundGetSnapshot, boundGetSnapshot, selector, compare);
    return selectedSnapshot;
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useSpawn.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useSpawn",
    ()=>useSpawn
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$behaviors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/es/behaviors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useConstant.js [app-ssr] (ecmascript)");
;
;
function useSpawn(behavior) {
    var actorRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useConstant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(function() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$xstate$40$4$2e$38$2e$3$2f$node_modules$2f$xstate$2f$es$2f$behaviors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["spawnBehavior"])(behavior);
    });
    return actorRef;
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/createActorContext.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createActorContext",
    ()=>createActorContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useInterpret.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useActor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useSelector.js [app-ssr] (ecmascript)");
var __assign = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
;
;
;
;
function createActorContext(machine, interpreterOptions, observerOrListener) {
    var ReactContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"](null);
    var OriginalProvider = ReactContext.Provider;
    function Provider(_a) {
        var children = _a.children, _b = _a.machine, providedMachine = _b === void 0 ? machine : _b, options = _a.options;
        var actor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useInterpret"])(providedMachine, __assign(__assign({}, interpreterOptions), options), observerOrListener);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"](OriginalProvider, {
            value: actor
        }, children);
    }
    Provider.displayName = "ActorProvider(".concat(machine.id, ")");
    function useContext() {
        var actor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"](ReactContext);
        if (!actor) {
            throw new Error("You used a hook from \"".concat(Provider.displayName, "\" but it's not inside a <").concat(Provider.displayName, "> component."));
        }
        return actor;
    }
    function useActor() {
        var actor = useContext();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useActor"])(actor);
    }
    function useSelector(selector, compare) {
        var actor = useContext();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSelector"])(actor, selector, compare);
    }
    return {
        Provider: Provider,
        useActorRef: useContext,
        useActor: useActor,
        useSelector: useSelector
    };
}
}),
"[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createActorContext",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$createActorContext$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createActorContext"],
    "shallowEqual",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shallowEqual"],
    "useActor",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useActor"],
    "useInterpret",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useInterpret"],
    "useMachine",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useMachine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMachine"],
    "useSelector",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSelector"],
    "useSpawn",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSpawn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSpawn"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useMachine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useMachine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useActor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useActor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useInterpret$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useInterpret.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useSelector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$useSpawn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/useSpawn.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$xstate$2b$react$40$3$2e$2$2e$2_$40$types$2b$react$40$19$2e$2$2e$7_react$40$19$2e$2$2e$3_xstate$40$4$2e$38$2e$3$2f$node_modules$2f40$xstate$2f$react$2f$es$2f$createActorContext$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/createActorContext.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        cachedValue = useState({
            inst: {
                value: value,
                getSnapshot: getSnapshot
            }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({
                inst: inst
            });
        }, [
            subscribe,
            value,
            getSnapshot
        ]);
        useEffect(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({
                inst: inst
            });
            return subscribe(function() {
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
            });
        }, [
            subscribe
        ]);
        useDebugValue(value);
        return value;
    }
    function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
        } catch (error) {
            return !0;
        }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = ("TURBOPACK compile-time truthy", 1) ? useSyncExternalStore$1 : "TURBOPACK unreachable";
    exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/shim/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-ssr] (ecmascript)");
}
}),
"[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), shim = __turbopack_context__.r("[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/shim/index.js [app-ssr] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
            var inst = {
                hasValue: !1,
                value: null
            };
            instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(function() {
            function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                    hasMemo = !0;
                    memoizedSnapshot = nextSnapshot;
                    nextSnapshot = selector(nextSnapshot);
                    if (void 0 !== isEqual && inst.hasValue) {
                        var currentSelection = inst.value;
                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                    }
                    return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
            }
            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
                function() {
                    return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot ? void 0 : function() {
                    return memoizedSelector(maybeGetServerSnapshot());
                }
            ];
        }, [
            getSnapshot,
            getServerSnapshot,
            selector,
            isEqual
        ]);
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(function() {
            inst.hasValue = !0;
            inst.value = value;
        }, [
            value
        ]);
        useDebugValue(value);
        return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/shim/with-selector.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.2.3/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-ssr] (ecmascript)");
}
}),
"[project]/node_modules/.pnpm/use-isomorphic-layout-effect@1.2.1_@types+react@19.2.7_react@19.2.3/node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.esm.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>index
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
var isClient = typeof document !== 'undefined';
var noop = function noop() {};
var index = isClient ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useLayoutEffect"] : noop;
;
}),
"[project]/node_modules/.pnpm/@nhost+react@3.11.2_@types+react@19.2.7_graphql@16.8.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@nhost/react/dist/index.cjs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const g = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+nhost-js@3.3.1_graphql@16.8.1/node_modules/@nhost/nhost-js/dist/index.cjs.js [app-ssr] (ecmascript)"), p = __turbopack_context__.r("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), n = __turbopack_context__.r("[project]/node_modules/.pnpm/@xstate+react@3.2.2_@types+react@19.2.7_react@19.2.3_xstate@4.38.3/node_modules/@xstate/react/es/index.js [app-ssr] (ecmascript)"), C = __turbopack_context__.r("[project]/node_modules/.pnpm/jwt-decode@4.0.0/node_modules/jwt-decode/build/cjs/index.js [app-ssr] (ecmascript)"), k = g.NhostClient;
class L extends k {
    constructor(t){
        super({
            ...t,
            start: !1
        });
    }
}
const P = p.createContext({}), O = ({ nhost: e, initial: t, ...o })=>{
    const i = n.useInterpret(e.auth.client.machine, {
        devTools: e.devTools
    });
    e.auth.client.start({
        interpreter: i,
        initialSession: t,
        devTools: e.devTools
    });
    const d = p.useRef(!0);
    return p.useEffect(()=>{
        d.current ? d.current = !1 : t && i.send("SESSION_UPDATE", {
            data: {
                session: t
            }
        });
    }, [
        t,
        i
    ]), p.createElement(P.Provider, {
        value: e
    }, o.children);
}, M = O, I = ()=>{
    var o;
    const t = (o = p.useContext(P).auth) == null ? void 0 : o.client.interpreter;
    if (!t) throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
    return t;
}, x = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>({
            isAuthenticated: t.matches({
                authentication: "signedIn"
            }),
            isLoading: t.hasTag("loading"),
            error: t.context.errors.authentication || null,
            isError: t.matches({
                authentication: {
                    signedOut: "failed"
                }
            }),
            connectionAttempts: t.context.importTokenAttempts
        }), (t, o)=>t.isAuthenticated === o.isAuthenticated && t.isLoading === o.isLoading && t.connectionAttempts === o.connectionAttempts);
};
function N({ children: e }) {
    const { isAuthenticated: t } = x();
    return t ? p.createElement(p.Fragment, null, e) : null;
}
function R({ children: e }) {
    const { isAuthenticated: t } = x();
    return t ? null : p.createElement(p.Fragment, null, e);
}
const y = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>t.context.accessToken.value);
}, v = ()=>p.useContext(P), K = ()=>{
    const e = v(), [t, o] = p.useState(null), i = !t, d = !!t, [l, S] = p.useState(!1);
    return {
        add: async (u)=>{
            S(!0);
            const s = await g.addSecurityKeyPromise(e.auth.client, u), { error: r } = s;
            return r && o(r), S(!1), s;
        },
        isLoading: l,
        isSuccess: i,
        isError: d,
        error: t
    };
}, D = ()=>{
    const e = I(), [t, o] = p.useState(!!e.status && e.getSnapshot().matches({
        authentication: "signedIn"
    }));
    return p.useEffect(()=>e.subscribe((d)=>{
            const l = d.matches({
                authentication: "signedIn"
            });
            o(l);
        }).unsubscribe, [
        e
    ]), t;
};
function V(e) {
    const t = v(), o = p.useMemo(()=>g.createChangeEmailMachine(t.auth.client), [
        t
    ]), i = n.useInterpret(o), d = n.useSelector(i, (s)=>s.matches("requesting")), l = n.useSelector(i, (s)=>s.context.error), S = n.useSelector(i, (s)=>s.matches("idle.error")), m = n.useSelector(i, (s)=>s.matches("idle.success"));
    return {
        changeEmail: p.useCallback(async (s, r = e)=>g.changeEmailPromise(i, s, r), [
            i,
            e
        ]),
        isLoading: d,
        needsEmailVerification: m,
        isError: S,
        error: l
    };
}
const F = ()=>{
    const e = v(), t = p.useMemo(()=>g.createChangePasswordMachine(e.auth.client), [
        e
    ]), o = n.useInterpret(t), i = n.useSelector(o, (u)=>u.matches({
            idle: "error"
        })), d = n.useSelector(o, (u)=>u.matches({
            idle: "success"
        })), l = n.useSelector(o, (u)=>u.context.error), S = n.useSelector(o, (u)=>u.matches("requesting"));
    return {
        changePassword: (u)=>g.changePasswordPromise(o, u),
        isLoading: S,
        isSuccess: d,
        isError: i,
        error: l
    };
}, _ = ()=>{
    const e = v(), t = p.useMemo(()=>g.createEnableMfaMachine(e.auth.client), [
        e
    ]), o = n.useInterpret(t), i = n.useSelector(o, (f)=>f.matches({
            idle: "error"
        }) || f.matches({
            generated: {
                idle: "error"
            }
        })), d = n.useSelector(o, (f)=>f.matches("generating")), l = n.useSelector(o, (f)=>f.matches("generated")), S = n.useSelector(o, (f)=>f.matches({
            generated: "activating"
        })), m = n.useSelector(o, (f)=>f.matches({
            generated: "activated"
        })), u = n.useSelector(o, (f)=>f.matches("disabling")), s = n.useSelector(o, (f)=>f.context.error), r = n.useSelector(o, (f)=>f.context.imageUrl || ""), c = n.useSelector(o, (f)=>f.context.secret || "");
    return {
        generateQrCode: ()=>g.generateQrCodePromise(o),
        isGenerating: d,
        qrCodeDataUrl: r,
        isGenerated: l,
        activateMfa: (f)=>g.activateMfaPromise(o, f),
        isActivating: S,
        isActivated: m,
        isDisabling: u,
        isError: i,
        error: s,
        disableMfa: (f)=>g.disableMfaPromise(o, f),
        totpSecret: c
    };
}, w = ()=>{
    const e = y();
    return e ? C.jwtDecode(e) : null;
}, A = (e)=>{
    const t = v(), o = (h)=>{
        e.send({
            type: "ADD",
            file: h.file,
            bucketId: h.bucketId || E
        });
    }, i = (h)=>g.uploadFilePromise({
            url: t.storage.url,
            accessToken: t.auth.getAccessToken(),
            adminSecret: t.adminSecret,
            ...h
        }, e), d = ()=>{
        e.send("CANCEL");
    }, l = ()=>{
        e.send("DESTROY");
    }, S = n.useSelector(e, (h)=>h.matches("uploading")), m = n.useSelector(e, (h)=>h.matches("uploaded")), u = n.useSelector(e, (h)=>h.matches("error")), s = n.useSelector(e, (h)=>h.context.error || null), r = n.useSelector(e, (h)=>h.context.progress), c = n.useSelector(e, (h)=>h.context.id), E = n.useSelector(e, (h)=>h.context.bucketId), a = n.useSelector(e, (h)=>{
        var f;
        return (f = h.context.file) == null ? void 0 : f.name;
    });
    return {
        add: o,
        upload: i,
        cancel: d,
        destroy: l,
        isUploaded: m,
        isUploading: S,
        isError: u,
        error: s,
        progress: r,
        id: c,
        bucketId: E,
        name: a
    };
}, q = ()=>{
    const e = n.useInterpret(g.createFileUploadMachine);
    return A(e);
}, T = ()=>{
    const e = w();
    return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
}, H = (e)=>{
    const t = T();
    return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
}, j = ()=>{
    const e = v(), [t, o] = p.useState([]), i = n.useInterpret(g.createMultipleFilesUploadMachine, {}, (a)=>{
        a.event.type === "UPLOAD_ERROR" ? o(a.context.files.filter((h)=>{
            var f;
            return (f = h.getSnapshot()) == null ? void 0 : f.context.error;
        })) : (a.matches("uploaded") || a.event.type === "CLEAR") && t.length > 0 && o([]);
    }), d = (a)=>{
        i.send({
            type: "ADD",
            ...a
        });
    }, l = (a)=>g.uploadMultipleFilesPromise({
            url: e.storage.url,
            accessToken: e.auth.getAccessToken(),
            adminSecret: e.adminSecret,
            ...a
        }, i), S = ()=>{
        i.send("CANCEL");
    }, m = ()=>{
        i.send("CLEAR");
    }, u = n.useSelector(i, (a)=>a.matches("uploading")), s = n.useSelector(i, (a)=>a.matches("uploaded")), r = n.useSelector(i, (a)=>a.matches("error")), c = n.useSelector(i, (a)=>a.context.progress), E = n.useSelector(i, (a)=>a.context.files);
    return {
        upload: l,
        add: d,
        clear: m,
        cancel: S,
        progress: c,
        isUploaded: s,
        isUploading: u,
        files: E,
        isError: r,
        errors: t
    };
}, Q = (e)=>{
    const [t, o] = p.useState(!0), i = y();
    p.useEffect(()=>{
        o(!1);
    }, []);
    const d = p.useContext(P);
    return new Proxy({}, {
        get (l, S) {
            let m = `${d.auth.client.backendUrl}/signin/provider/${S}`;
            const u = e != null && e.connect ? {
                connect: i
            } : {};
            return g.encodeQueryParameters(m, g.rewriteRedirectTo(t ? void 0 : d.auth.client.clientUrl, {
                ...e,
                ...u
            }));
        }
    });
}, J = (e)=>{
    const t = v(), o = p.useMemo(()=>g.createResetPasswordMachine(t.auth.client), [
        t
    ]), i = n.useInterpret(o), d = n.useSelector(i, (s)=>s.matches("requesting")), l = n.useSelector(i, (s)=>s.context.error), S = n.useSelector(i, (s)=>s.matches("idle.error")), m = n.useSelector(i, (s)=>s.matches("idle.success"));
    return {
        resetPassword: (s, r = e)=>g.resetPasswordPromise(i, s, r),
        isLoading: d,
        isSent: m,
        isError: S,
        error: l
    };
}, Y = (e)=>{
    const t = v(), o = p.useMemo(()=>g.createSendVerificationEmailMachine(t.auth.client), [
        t
    ]), i = n.useInterpret(o), d = n.useSelector(i, (s)=>s.matches({
            idle: "error"
        })), l = n.useSelector(i, (s)=>s.matches({
            idle: "success"
        })), S = n.useSelector(i, (s)=>s.context.error), m = n.useSelector(i, (s)=>s.matches("requesting"));
    return {
        sendEmail: (s, r = e)=>g.sendVerificationEmailPromise(i, s, r),
        isLoading: m,
        isSent: l,
        isError: d,
        error: S
    };
}, $ = ()=>{
    const e = I(), t = ()=>g.signInAnonymousPromise(e), o = n.useSelector(e, (u)=>u.context.errors.authentication || null, (u, s)=>(u == null ? void 0 : u.error) === (s == null ? void 0 : s.error)), i = n.useSelector(e, (u)=>u.matches({
            authentication: {
                authenticating: "anonymous"
            }
        })), d = n.useSelector(e, (u)=>u.matches({
            authentication: "signedIn"
        })), l = n.useSelector(e, (u)=>u.matches({
            authentication: {
                signedOut: "failed"
            }
        })), S = n.useSelector(e, (u)=>u.context.user, (u, s)=>(u == null ? void 0 : u.id) === (s == null ? void 0 : s.id));
    return {
        accessToken: n.useSelector(e, (u)=>u.context.accessToken.value),
        error: o,
        isError: l,
        isLoading: i,
        isSuccess: d,
        signInAnonymous: t,
        user: S
    };
}, G = ()=>{
    const e = I(), t = (a, h)=>g.signInEmailPasswordPromise(e, a, h), o = (a)=>g.signInMfaTotpPromise(e, a), i = n.useSelector(e, (a)=>a.context.user, (a, h)=>(a == null ? void 0 : a.id) === (h == null ? void 0 : h.id)), d = n.useSelector(e, (a)=>a.context.accessToken.value), l = n.useSelector(e, (a)=>a.context.refreshToken.value), S = n.useSelector(e, (a)=>a.context.errors.authentication || null, (a, h)=>(a == null ? void 0 : a.error) === (h == null ? void 0 : h.error)), m = n.useSelector(e, (a)=>a.matches({
            authentication: "signedIn"
        })), u = n.useSelector(e, (a)=>a.matches({
            authentication: {
                authenticating: "password"
            }
        }), (a, h)=>a === h), s = n.useSelector(e, (a)=>a.matches({
            authentication: {
                signedOut: "noErrors"
            },
            registration: {
                incomplete: "needsEmailVerification"
            }
        }), (a, h)=>a === h), r = n.useSelector(e, (a)=>a.context.mfa !== null), c = n.useSelector(e, (a)=>a.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (a, h)=>a === h), E = n.useSelector(e, (a)=>a.context.mfa);
    return {
        accessToken: d,
        refreshToken: l,
        error: S,
        isError: c,
        isLoading: u,
        isSuccess: m,
        needsEmailVerification: s,
        needsMfaOtp: r,
        mfa: E,
        sendMfaOtp: o,
        signInEmailPassword: t,
        user: i
    };
};
function W(e) {
    const t = I(), o = (m, u = e)=>g.signInEmailPasswordlessPromise(t, m, u), i = n.useSelector(t, (m)=>m.context.errors.registration || null, (m, u)=>(m == null ? void 0 : m.error) === (u == null ? void 0 : u.error)), d = n.useSelector(t, (m)=>m.matches("registration.passwordlessEmail")), l = n.useSelector(t, (m)=>m.matches("registration.incomplete.needsEmailVerification")), S = n.useSelector(t, (m)=>m.matches("registration.incomplete.failed"));
    return {
        signInEmailPasswordless: o,
        isLoading: d,
        isSuccess: l,
        isError: S,
        error: i
    };
}
const z = ()=>{
    const e = I(), t = (r)=>g.signInEmailSecurityKeyPromise(e, r), o = n.useSelector(e, (r)=>r.context.user, (r, c)=>(r == null ? void 0 : r.id) === (c == null ? void 0 : c.id)), i = n.useSelector(e, (r)=>r.context.accessToken.value), d = n.useSelector(e, (r)=>r.context.refreshToken.value), l = n.useSelector(e, (r)=>r.context.errors.authentication || null, (r, c)=>(r == null ? void 0 : r.error) === (c == null ? void 0 : c.error)), S = n.useSelector(e, (r)=>r.matches({
            authentication: "signedIn"
        })), m = n.useSelector(e, (r)=>r.matches({
            authentication: {
                authenticating: "securityKeyEmail"
            }
        }), (r, c)=>r === c), u = n.useSelector(e, (r)=>r.matches({
            authentication: {
                signedOut: "noErrors"
            },
            registration: {
                incomplete: "needsEmailVerification"
            }
        }), (r, c)=>r === c), s = n.useSelector(e, (r)=>r.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (r, c)=>r === c);
    return {
        accessToken: i,
        refreshToken: d,
        error: l,
        isError: s,
        isLoading: m,
        isSuccess: S,
        needsEmailVerification: u,
        signInEmailSecurityKey: t,
        user: o
    };
}, U = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>t.context.user, (t, o)=>(t && JSON.stringify(t)) === (o && JSON.stringify(o)));
}, B = ()=>{
    const e = U(), t = v(), o = T(), i = e ? (o == null ? void 0 : o["x-hasura-auth-elevated"]) === (e == null ? void 0 : e.id) : !1, [d, l] = p.useState(!!i), S = (m)=>g.elevateEmailSecurityKeyPromise(t.auth.client, m);
    return p.useEffect(()=>{
        l(!!i);
    }, [
        i
    ]), {
        elevated: d,
        elevateEmailSecurityKey: S
    };
}, X = ()=>{
    const e = I(), t = (s)=>g.signInPATPromise(e, s), o = n.useSelector(e, (s)=>s.context.user, (s, r)=>(s == null ? void 0 : s.id) === (r == null ? void 0 : r.id)), i = n.useSelector(e, (s)=>s.context.accessToken.value), d = n.useSelector(e, (s)=>s.context.refreshToken.value), l = n.useSelector(e, (s)=>s.context.errors.authentication || null, (s, r)=>(s == null ? void 0 : s.error) === (r == null ? void 0 : r.error)), S = n.useSelector(e, (s)=>s.matches({
            authentication: "signedIn"
        })), m = n.useSelector(e, (s)=>s.matches({
            authentication: {
                authenticating: "password"
            }
        }), (s, r)=>s === r), u = n.useSelector(e, (s)=>s.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (s, r)=>s === r);
    return {
        accessToken: i,
        refreshToken: d,
        error: l,
        isError: u,
        isLoading: m,
        isSuccess: S,
        signInPAT: t,
        user: o
    };
};
function Z(e) {
    const t = I(), [o, i] = p.useState(""), d = (c, E = e)=>(i(c), g.signInSmsPasswordlessPromise(t, c, E)), l = async (...c)=>{
        if (c.length === 2) {
            const [a, h] = c;
            return g.signInSmsPasswordlessOtpPromise(t, a, h);
        }
        const [E] = c;
        return g.signInSmsPasswordlessOtpPromise(t, o, E);
    }, S = n.useSelector(t, (c)=>c.context.errors.registration || null, (c, E)=>(c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)), m = n.useSelector(t, (c)=>c.matches("registration.passwordlessSms") || c.matches("registration.passwordlessSmsOtp")), u = n.useSelector(t, (c)=>c.matches("authentication.signedIn")), s = n.useSelector(t, (c)=>c.matches("registration.incomplete.needsOtp")), r = n.useSelector(t, (c)=>c.matches("registration.incomplete.failed"));
    return {
        signInSmsPasswordless: d,
        sendOtp: l,
        isLoading: m,
        isSuccess: u,
        needsOtp: s,
        isError: r,
        error: S
    };
}
const b = (e = !1)=>{
    const t = I(), o = (l)=>g.signOutPromise(t, typeof l == "boolean" ? l : e), i = n.useSelector(t, (l)=>l.matches({
            authentication: {
                signedOut: "success"
            }
        }), (l, S)=>l === S), d = n.useSelector(t, (l)=>l.context.errors.signout || null, (l, S)=>(l == null ? void 0 : l.error) === (S == null ? void 0 : S.error));
    return {
        signOut: o,
        isSuccess: i,
        error: d
    };
}, ee = (e)=>{
    const t = I(), o = n.useSelector(t, (c)=>!!c.context.errors.registration), i = n.useSelector(t, (c)=>c.context.errors.registration || null, (c, E)=>(c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)), d = n.useSelector(t, (c)=>c.matches("registration.emailPassword")), l = n.useSelector(t, (c)=>c.matches("registration.incomplete.needsEmailVerification")), S = n.useSelector(t, (c)=>c.matches({
            authentication: "signedIn",
            registration: "complete"
        })), m = (c, E, a = e, h)=>g.signUpEmailPasswordPromise(t, c, E, a, h), u = n.useSelector(t, (c)=>c.context.user, (c, E)=>(c == null ? void 0 : c.id) === (E == null ? void 0 : E.id)), s = n.useSelector(t, (c)=>c.context.accessToken.value), r = n.useSelector(t, (c)=>c.context.refreshToken.value);
    return {
        accessToken: s,
        refreshToken: r,
        error: i,
        isError: o,
        isLoading: d,
        isSuccess: S,
        needsEmailVerification: l,
        signUpEmailPassword: m,
        user: u
    };
}, te = (e)=>{
    const t = I(), o = n.useSelector(t, (c)=>!!c.context.errors.registration), i = n.useSelector(t, (c)=>c.context.errors.registration || null, (c, E)=>(c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)), d = n.useSelector(t, (c)=>c.matches("registration.securityKey")), l = n.useSelector(t, (c)=>c.matches("registration.incomplete.needsEmailVerification")), S = n.useSelector(t, (c)=>c.matches({
            authentication: "signedIn",
            registration: "complete"
        })), m = (c, E = e, a)=>g.signUpEmailSecurityKeyPromise(t, c, E, a), u = n.useSelector(t, (c)=>c.context.user, (c, E)=>(c == null ? void 0 : c.id) === (E == null ? void 0 : E.id)), s = n.useSelector(t, (c)=>c.context.accessToken.value), r = n.useSelector(t, (c)=>c.context.refreshToken.value);
    return {
        accessToken: s,
        refreshToken: r,
        error: i,
        isError: o,
        isLoading: d,
        isSuccess: S,
        needsEmailVerification: l,
        signUpEmailSecurityKey: m,
        user: u
    };
}, se = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.avatarUrl;
    }, (t, o)=>t === o);
}, ne = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.defaultRole;
    }, (t, o)=>t === o);
}, re = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.displayName;
    }, (t, o)=>t === o);
}, oe = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.email;
    }, (t, o)=>t === o);
}, ce = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.id;
    }, (t, o)=>t === o);
}, ie = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.isAnonymous;
    }, (t, o)=>t === o);
}, ue = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return (o = t.context.user) == null ? void 0 : o.locale;
    }, (t, o)=>t === o);
}, ae = ()=>{
    const e = I();
    return n.useSelector(e, (t)=>{
        var o;
        return t.matches("authentication.signedIn") ? ((o = t.context.user) == null ? void 0 : o.roles) || [] : [];
    });
};
function le(e) {
    const t = I(), o = (s, r = e)=>g.signInEmailOTPPromise(t, s, r), i = async (s, r)=>g.verifyEmailOTPPromise(t, s, r), d = n.useSelector(t, (s)=>s.context.errors.registration || null, (s, r)=>(s == null ? void 0 : s.error) === (r == null ? void 0 : r.error)), l = n.useSelector(t, (s)=>s.matches("registration.signInEmailOTP") || s.matches("registration.verifyEmailOTP")), S = n.useSelector(t, (s)=>s.matches("authentication.signedIn")), m = n.useSelector(t, (s)=>s.matches("registration.incomplete.needsOtp")), u = n.useSelector(t, (s)=>s.matches("registration.incomplete.failed"));
    return {
        signInEmailOTP: o,
        verifyEmailOTP: i,
        isLoading: l,
        isSuccess: S,
        isError: u,
        error: d,
        needsOtp: m
    };
}
const de = ()=>{
    const e = I(), t = (s, r, c)=>g.signInIdTokenPromise(e, {
            provider: s,
            idToken: r,
            nonce: c
        }), o = n.useSelector(e, (s)=>s.context.user, (s, r)=>(s == null ? void 0 : s.id) === (r == null ? void 0 : r.id)), i = n.useSelector(e, (s)=>s.context.accessToken.value), d = n.useSelector(e, (s)=>s.context.refreshToken.value), l = n.useSelector(e, (s)=>s.context.errors.authentication || null, (s, r)=>(s == null ? void 0 : s.error) === (r == null ? void 0 : r.error)), S = n.useSelector(e, (s)=>s.matches({
            authentication: "signedIn"
        })), m = n.useSelector(e, (s)=>s.matches({
            authentication: {
                authenticating: "idToken"
            }
        }), (s, r)=>s === r), u = n.useSelector(e, (s)=>s.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (s, r)=>s === r);
    return {
        accessToken: i,
        refreshToken: d,
        error: l,
        isError: u,
        isLoading: m,
        isSuccess: S,
        signInIdToken: t,
        user: o
    };
}, Se = ()=>{
    const e = v(), [t, o] = p.useState(null), i = !t, d = !!t, [l, S] = p.useState(!1);
    return {
        linkIdToken: async ({ provider: u, idToken: s, nonce: r })=>{
            S(!0);
            const c = await g.linkIdTokenPromise(e.auth.client, {
                provider: u,
                idToken: s,
                ...r && {
                    nonce: r
                }
            }), { error: E } = c;
            return E && o(E), S(!1), c;
        },
        isLoading: l,
        isSuccess: i,
        isError: d,
        error: t
    };
}, me = ()=>{
    const e = I(), t = ()=>g.signInSecurityKeyPromise(e), o = n.useSelector(e, (r)=>r.context.user, (r, c)=>(r == null ? void 0 : r.id) === (c == null ? void 0 : c.id)), i = n.useSelector(e, (r)=>r.context.accessToken.value), d = n.useSelector(e, (r)=>r.context.refreshToken.value), l = n.useSelector(e, (r)=>r.context.errors.authentication || null, (r, c)=>(r == null ? void 0 : r.error) === (c == null ? void 0 : c.error)), S = n.useSelector(e, (r)=>r.matches({
            authentication: "signedIn"
        })), m = n.useSelector(e, (r)=>r.matches({
            authentication: {
                authenticating: "securityKeyEmail"
            }
        }), (r, c)=>r === c), u = n.useSelector(e, (r)=>r.matches({
            authentication: {
                signedOut: "noErrors"
            },
            registration: {
                incomplete: "needsEmailVerification"
            }
        }), (r, c)=>r === c), s = n.useSelector(e, (r)=>r.matches({
            authentication: {
                signedOut: "failed"
            }
        }), (r, c)=>r === c);
    return {
        accessToken: i,
        refreshToken: d,
        error: l,
        isError: s,
        isLoading: m,
        isSuccess: S,
        needsEmailVerification: u,
        signInSecurityKey: t,
        user: o
    };
};
Object.defineProperty(exports, "NHOST_REFRESH_TOKEN_KEY", {
    enumerable: !0,
    get: ()=>g.NHOST_REFRESH_TOKEN_KEY
});
exports.NhostClient = L;
exports.NhostProvider = O;
exports.NhostReactContext = P;
exports.NhostReactProvider = M;
exports.SignedIn = N;
exports.SignedOut = R;
exports.VanillaNhostClient = k;
exports.useAccessToken = y;
exports.useAddSecurityKey = K;
exports.useAuthInterpreter = I;
exports.useAuthenticated = D;
exports.useAuthenticationStatus = x;
exports.useChangeEmail = V;
exports.useChangePassword = F;
exports.useConfigMfa = _;
exports.useDecodedAccessToken = w;
exports.useElevateSecurityKeyEmail = B;
exports.useFileUpload = q;
exports.useFileUploadItem = A;
exports.useHasuraClaim = H;
exports.useHasuraClaims = T;
exports.useLinkIdToken = Se;
exports.useMultipleFilesUpload = j;
exports.useNhostClient = v;
exports.useProviderLink = Q;
exports.useResetPassword = J;
exports.useSendVerificationEmail = Y;
exports.useSignInAnonymous = $;
exports.useSignInEmailOTP = le;
exports.useSignInEmailPassword = G;
exports.useSignInEmailPasswordless = W;
exports.useSignInEmailSecurityKey = z;
exports.useSignInIdToken = de;
exports.useSignInPAT = X;
exports.useSignInSecurityKey = me;
exports.useSignInSmsPasswordless = Z;
exports.useSignOut = b;
exports.useSignUpEmailPassword = ee;
exports.useSignUpEmailSecurityKeyEmail = te;
exports.useUserAvatarUrl = se;
exports.useUserData = U;
exports.useUserDefaultRole = ne;
exports.useUserDisplayName = re;
exports.useUserEmail = oe;
exports.useUserId = ce;
exports.useUserIsAnonymous = ie;
exports.useUserLocale = ue;
exports.useUserRoles = ae; //# sourceMappingURL=index.cjs.js.map
}),
"[project]/node_modules/.pnpm/@nhost+nextjs@2.3.1_@types+react@19.2.7_next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_a6ca12aedbce5d8cfa4157182c419292/node_modules/@nhost/nextjs/dist/index.cjs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
});
const i = __turbopack_context__.r("[project]/node_modules/.pnpm/@nhost+react@3.11.2_@types+react@19.2.7_graphql@16.8.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@nhost/react/dist/index.cjs.js [app-ssr] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/.pnpm/isomorphic-unfetch@3.1.0/node_modules/isomorphic-unfetch/index.js [app-ssr] (ecmascript)");
const c = __turbopack_context__.r("[project]/node_modules/.pnpm/js-cookie@3.0.5/node_modules/js-cookie/dist/js.cookie.js [app-ssr] (ecmascript)"), p = __turbopack_context__.r("[project]/node_modules/.pnpm/xstate@4.38.3/node_modules/xstate/lib/waitFor.js [app-ssr] (ecmascript)"), l = "nhostSession", T = (e)=>{
    const t = e && "auth" in e ? e.auth.getSession() : e;
    if (!t) {
        c.remove(l);
        return;
    }
    const { refreshToken: o, ...r } = t, n = new Date;
    n.setSeconds(n.getSeconds() + t.accessTokenExpiresIn - 60), c.set(l, JSON.stringify(r), {
        sameSite: "strict",
        expires: n
    });
}, N = async (e, t)=>{
    const o = new i.VanillaNhostClient({
        ...e,
        clientStorageType: "custom",
        clientStorage: {
            getItem: (s)=>{
                var g;
                const u = s === i.NHOST_REFRESH_TOKEN_KEY ? "refreshToken" : s, S = t.query[u], h = (g = c.get(s)) != null ? g : null, d = t.req.cookies[s];
                return typeof S == "string" ? S : h != null ? h : d;
            },
            setItem: (s, u)=>{
                c.set(s, u, {
                    httpOnly: !1,
                    sameSite: "strict",
                    expires: 30
                });
            },
            removeItem: (s)=>{
                c.remove(s);
            }
        },
        start: !1,
        autoRefreshToken: !1,
        autoSignIn: !0
    }), r = t.req.cookies[l], n = t.req.cookies[i.NHOST_REFRESH_TOKEN_KEY], a = r && n && {
        ...JSON.parse(r),
        refreshToken: n
    };
    return o.auth.client.start({
        initialSession: a
    }), await p.waitFor(o.auth.client.interpreter, (s)=>!s.hasTag("loading")), o;
}, O = async (e, t)=>{
    const o = await N(e, t), { accessToken: r, refreshToken: n, user: a } = o.auth.client.interpreter.getSnapshot().context;
    return o.auth.isAuthenticated() ? {
        accessToken: r.value,
        accessTokenExpiresIn: (r.expiresAt.getTime() - Date.now()) / 1e3,
        refreshToken: n.value,
        user: a
    } : null;
}, k = i.NhostProvider, f = ("TURBOPACK compile-time value", "undefined") != "undefined";
class y extends i.NhostClient {
    constructor(t){
        super({
            ...t,
            autoSignIn: f && t.autoSignIn,
            autoRefreshToken: f && t.autoRefreshToken,
            clientStorageType: "cookie"
        }), this.auth.onAuthStateChanged(()=>{
            T(this);
        }), this.auth.onTokenChanged(T);
    }
}
exports.NhostClient = y;
exports.NhostNextProvider = k;
exports.createServerSideClient = N;
exports.getNhostSession = O;
Object.keys(i).forEach((e)=>{
    e !== "default" && !Object.prototype.hasOwnProperty.call(exports, e) && Object.defineProperty(exports, e, {
        enumerable: !0,
        get: ()=>i[e]
    });
}); //# sourceMappingURL=index.cjs.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/invariantErrorCodes.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// This file is used by the error message display website and the
// @apollo/client/includeErrors entry point.
// This file is not meant to be imported manually.
__turbopack_context__.s([
    "devDebug",
    ()=>devDebug,
    "devError",
    ()=>devError,
    "devLog",
    ()=>devLog,
    "devWarn",
    ()=>devWarn,
    "errorCodes",
    ()=>errorCodes
]);
const errorCodes = {
    1: {
        file: "@apollo/client/utilities/internal/checkDocument.js",
        condition: "doc && doc.kind === \"Document\"",
        message: `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \
string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql`
    },
    2: {
        file: "@apollo/client/utilities/internal/checkDocument.js",
        message: `Schema type definitions not allowed in queries. Found: "%s"`
    },
    3: {
        file: "@apollo/client/utilities/internal/checkDocument.js",
        condition: "operations.length <= 1",
        message: `Ambiguous GraphQL document: contains %s operations`
    },
    4: {
        file: "@apollo/client/utilities/internal/checkDocument.js",
        condition: "operations.length == 1 && operations[0].operation === expectedType",
        message: `Running a %s requires a graphql ` + `%s, but a %s was used instead.`
    },
    5: {
        file: "@apollo/client/utilities/internal/checkDocument.js",
        message: '`%s` is a forbidden field alias name in the selection set for field `%s` in %s "%s".'
    },
    6: {
        file: "@apollo/client/utilities/internal/getFragmentDefinition.js",
        condition: "doc.kind === \"Document\"",
        message: `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \
string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql`
    },
    7: {
        file: "@apollo/client/utilities/internal/getFragmentDefinition.js",
        condition: "doc.definitions.length <= 1",
        message: "Fragment must have exactly one definition."
    },
    8: {
        file: "@apollo/client/utilities/internal/getFragmentDefinition.js",
        condition: "fragmentDef.kind === \"FragmentDefinition\"",
        message: "Must be a fragment definition."
    },
    9: {
        file: "@apollo/client/utilities/internal/getFragmentFromSelection.js",
        condition: "fragment",
        message: `No fragment named %s`
    },
    10: {
        file: "@apollo/client/utilities/internal/getFragmentQueryDocument.js",
        message: `Found a %s operation%s. ` + "No operations are allowed when using a fragment as a query. Only fragments are allowed."
    },
    11: {
        file: "@apollo/client/utilities/internal/getFragmentQueryDocument.js",
        condition: "fragments.length === 1",
        message: `Found %s fragments. \`fragmentName\` must be provided when there is not exactly 1 fragment.`
    },
    12: {
        file: "@apollo/client/utilities/internal/getMainDefinition.js",
        message: "Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment."
    },
    13: {
        file: "@apollo/client/utilities/internal/getQueryDefinition.js",
        condition: "queryDef && queryDef.operation === \"query\"",
        message: "Must contain a query definition."
    },
    15: {
        file: "@apollo/client/utilities/internal/shouldInclude.js",
        condition: "evaledValue !== void 0",
        message: `Invalid variable referenced in @%s directive.`
    },
    16: {
        file: "@apollo/client/utilities/internal/shouldInclude.js",
        condition: "directiveArguments && directiveArguments.length === 1",
        message: `Incorrect number of arguments for the @%s directive.`
    },
    17: {
        file: "@apollo/client/utilities/internal/shouldInclude.js",
        condition: "ifArgument.name && ifArgument.name.value === \"if\"",
        message: `Invalid argument for the @%s directive.`
    },
    18: {
        file: "@apollo/client/utilities/internal/shouldInclude.js",
        condition: "ifValue &&\n    (ifValue.kind === \"Variable\" || ifValue.kind === \"BooleanValue\")",
        message: `Argument for the @%s directive must be a variable or a boolean value.`
    },
    19: {
        file: "@apollo/client/utilities/internal/valueToObjectRepresentation.js",
        message: `The inline argument "%s" of kind "%s"` + "is not supported. Use variables instead of inline arguments to " + "overcome this limitation."
    },
    20: {
        file: "@apollo/client/utilities/graphql/DocumentTransform.js",
        condition: "Array.isArray(cacheKeys)",
        message: "`getCacheKey` must return an array or undefined"
    },
    21: {
        file: "@apollo/client/testing/core/mocking/mockLink.js",
        condition: "max > min",
        message: "realisticDelay: `min` must be less than `max`"
    },
    22: {
        file: "@apollo/client/testing/core/mocking/mockLink.js",
        condition: "queryWithoutClientOnlyDirectives",
        message: "query is required"
    },
    23: {
        file: "@apollo/client/testing/core/mocking/mockLink.js",
        condition: "serverQuery",
        message: "Cannot mock a client-only query. Mocked responses should contain at least one non-client field."
    },
    24: {
        file: "@apollo/client/testing/core/mocking/mockLink.js",
        condition: "(mock.maxUsageCount ?? 1) > 0",
        message: "Mocked response `maxUsageCount` must be greater than 0. Given %s"
    },
    25: {
        file: "@apollo/client/react/ssr/prerenderStatic.js",
        condition: "renderCount <= maxRerenders",
        message: `Exceeded maximum rerender count of %d.
This either means you have very deep \`useQuery\` waterfalls in your application
and need to increase the \`maxRerender\` option to \`prerenderStatic\`, or that
you have an infinite render loop in your application.`
    },
    26: {
        file: "@apollo/client/react/ssr/prerenderStatic.js",
        condition: "!signal?.aborted",
        message: "The operation was aborted before it could be attempted."
    },
    27: {
        file: "@apollo/client/react/internal/cache/QueryReference.js",
        condition: "!queryRef || QUERY_REFERENCE_SYMBOL in queryRef",
        message: "Expected a QueryRef object, but got something else instead."
    },
    28: {
        file: "@apollo/client/react/hooks/useApolloClient.js",
        condition: "!!client",
        message: 'Could not find "client" in the context or passed in as an option. ' + "Wrap the root component in an <ApolloProvider>, or pass an ApolloClient " + "instance in via options."
    },
    29: {
        file: "@apollo/client/react/hooks/useLazyQuery.js",
        condition: "resultRef.current",
        message: "useLazyQuery: '%s' cannot be called before executing the query."
    },
    30: {
        file: "@apollo/client/react/hooks/useLazyQuery.js",
        condition: "!calledDuringRender()",
        message: "useLazyQuery: 'execute' should not be called during render. To start a query during render, use the 'useQuery' hook."
    },
    31: {
        file: "@apollo/client/react/hooks/useLoadableQuery.js",
        condition: "!calledDuringRender()",
        message: "useLoadableQuery: 'loadQuery' should not be called during render. To start a query during render, use the 'useBackgroundQuery' hook."
    },
    32: {
        file: "@apollo/client/react/hooks/useLoadableQuery.js",
        condition: "internalQueryRef",
        message: "The query has not been loaded. Please load the query."
    },
    33: {
        file: "@apollo/client/react/hooks/useSubscription.js",
        condition: "!optionsRef.current.skip",
        message: "A subscription that is skipped cannot be restarted."
    },
    35: {
        file: "@apollo/client/react/hooks/internal/validateSuspenseHookOptions.js",
        condition: "supportedFetchPolicies.includes(fetchPolicy)",
        message: `The fetch policy \`%s\` is not supported with suspense.`
    },
    37: {
        file: "@apollo/client/react/context/ApolloContext.js",
        condition: "\"createContext\" in React",
        message: "Invoking `getApolloContext` in an environment where `React.createContext` is not available.\n" + "The Apollo Client functionality you are trying to use is only available in React Client Components.\n" + 'Please make sure to add "use client" at the top of your file.\n' + // TODO: change to React documentation once React documentation contains information about Client Components
        "For more information, see https://nextjs.org/docs/getting-started/react-essentials#client-components"
    },
    38: {
        file: "@apollo/client/react/context/ApolloProvider.js",
        condition: "context.client",
        message: "ApolloProvider was not passed a client instance. Make " + 'sure you pass in your client via the "client" prop.'
    },
    39: {
        file: "@apollo/client/masking/maskDefinition.js",
        condition: "fragment",
        message: "Could not find fragment with name '%s'."
    },
    41: {
        file: "@apollo/client/masking/maskFragment.js",
        condition: "fragments.length === 1",
        message: `Found %s fragments. \`fragmentName\` must be provided when there is not exactly 1 fragment.`
    },
    42: {
        file: "@apollo/client/masking/maskFragment.js",
        condition: "!!fragment",
        message: `Could not find fragment with name "%s".`
    },
    43: {
        file: "@apollo/client/masking/maskOperation.js",
        condition: "definition",
        message: "Expected a parsed GraphQL document with a query, mutation, or subscription."
    },
    47: {
        file: "@apollo/client/local-state/LocalState.js",
        condition: "hasDirectives([\"client\"], document)",
        message: "Expected document to contain `@client` fields."
    },
    48: {
        file: "@apollo/client/local-state/LocalState.js",
        condition: "hasDirectives([\"client\"], document)",
        message: "Expected document to contain `@client` fields."
    },
    49: {
        file: "@apollo/client/local-state/LocalState.js",
        condition: "fragment",
        message: "No fragment named %s"
    },
    53: {
        file: "@apollo/client/local-state/LocalState.js",
        message: "Could not resolve __typename on object %o returned from resolver '%s'. '__typename' needs to be returned to properly resolve child fields."
    },
    54: {
        file: "@apollo/client/local-state/LocalState.js",
        condition: "fragment",
        message: `No fragment named %s`
    },
    55: {
        file: "@apollo/client/local-state/LocalState.js",
        condition: "cache.fragmentMatches",
        message: "The configured cache does not support fragment matching which will lead to incorrect results when executing local resolvers. Please use a cache that implements `fragmetMatches`."
    },
    57: {
        file: "@apollo/client/link/persisted-queries/index.js",
        condition: "options &&\n    (typeof options.sha256 === \"function\" ||\n        typeof options.generateHash === \"function\")",
        message: 'Missing/invalid "sha256" or "generateHash" function. Please ' + 'configure one using the "createPersistedQueryLink(options)" options ' + "parameter."
    },
    58: {
        file: "@apollo/client/link/persisted-queries/index.js",
        condition: "forward",
        message: "PersistedQueryLink cannot be the last link in the chain."
    },
    59: {
        file: "@apollo/client/link/http/checkFetcher.js",
        condition: "fetcher || typeof fetch !== \"undefined\"",
        message: `
"fetch" has not been found globally and no fetcher has been \
configured. To fix this, install a fetch package (like \
https://www.npmjs.com/package/cross-fetch), instantiate the \
fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `
    },
    60: {
        file: "@apollo/client/link/http/parseAndCheckHttpResponse.js",
        condition: "response.body && typeof response.body.getReader === \"function\"",
        message: "Unknown type for `response.body`. Please use a `fetch` implementation that is WhatWG-compliant and that uses WhatWG ReadableStreams for `body`."
    },
    63: {
        file: "@apollo/client/link/core/ApolloLink.js",
        message: "request is not implemented"
    },
    64: {
        file: "@apollo/client/incremental/handlers/notImplemented.js",
        condition: "!hasDirectives([\"defer\"], request.query)",
        message: "`@defer` is not supported without specifying an incremental handler. Please pass a handler as the `incrementalHandler` option to the `ApolloClient` constructor."
    },
    65: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "options.cache",
        message: "To initialize Apollo Client, you must specify a 'cache' property " + "in the options object. \n" + "For more information, please visit: https://go.apollo.dev/c/docs"
    },
    66: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "options.link",
        message: "To initialize Apollo Client, you must specify a 'link' property " + "in the options object. \n" + "For more information, please visit: https://go.apollo.dev/c/docs"
    },
    67: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "options.fetchPolicy !== \"cache-and-network\"",
        message: "The cache-and-network fetchPolicy does not work with client.query, because " + "client.query can only return a single result. Please use client.watchQuery " + "to receive multiple results from the cache and the network, or consider " + "using a different fetchPolicy, such as cache-first or network-only."
    },
    68: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "options.fetchPolicy !== \"standby\"",
        message: "The standby fetchPolicy does not work with client.query, because " + "standby does not fetch. Consider using a different fetchPolicy, such " + "as cache-first or network-only."
    },
    69: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "options.query",
        message: "query option is required. You must specify your GraphQL document " + "in the query option."
    },
    70: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "options.query.kind === \"Document\"",
        message: 'You must wrap the query string in a "gql" tag.'
    },
    71: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "!options.returnPartialData",
        message: "returnPartialData option only supported on watchQuery."
    },
    72: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "!options.pollInterval",
        message: "pollInterval option only supported on watchQuery."
    },
    73: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "!options.notifyOnNetworkStatusChange",
        message: "notifyOnNetworkStatusChange option only supported on watchQuery."
    },
    74: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "optionsWithDefaults.mutation",
        message: "The `mutation` option is required. Please provide a GraphQL document in the `mutation` option."
    },
    75: {
        file: "@apollo/client/core/ApolloClient.js",
        condition: "optionsWithDefaults.fetchPolicy === \"network-only\" ||\n    optionsWithDefaults.fetchPolicy === \"no-cache\"",
        message: "Mutations only support 'network-only' or 'no-cache' fetch policies. The default 'network-only' behavior automatically writes mutation results to the cache. Passing 'no-cache' skips the cache write."
    },
    77: {
        file: "@apollo/client/core/ObservableQuery.js",
        condition: "fetchPolicy === \"standby\"",
        message: "The `variablesUnknown` option can only be used together with a `standby` fetch policy."
    },
    79: {
        file: "@apollo/client/core/ObservableQuery.js",
        condition: "this.options.fetchPolicy !== \"cache-only\"",
        message: "Cannot execute `fetchMore` for 'cache-only' query '%s'. Please use a different fetch policy."
    },
    80: {
        file: "@apollo/client/core/ObservableQuery.js",
        condition: "updateQuery",
        message: "You must provide an `updateQuery` function when using `fetchMore` with a `no-cache` fetch policy."
    },
    84: {
        file: "@apollo/client/core/QueryManager.js",
        message: "QueryManager stopped while query was in flight"
    },
    85: {
        file: "@apollo/client/core/QueryManager.js",
        condition: "this.localState",
        message: "Mutation '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured."
    },
    86: {
        file: "@apollo/client/core/QueryManager.js",
        message: "Store reset while query was in flight (not completed in link chain)"
    },
    89: {
        file: "@apollo/client/core/QueryManager.js",
        condition: "!this.getDocumentInfo(query).hasClientExports || this.localState",
        message: "Subscription '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured."
    },
    90: {
        file: "@apollo/client/core/QueryManager.js",
        condition: "this.localState",
        message: "%s '%s' contains `@client` fields but local state has not been configured."
    },
    91: {
        file: "@apollo/client/core/QueryManager.js",
        condition: "!hasIncrementalDirective",
        message: "%s '%s' contains `@client` and `@defer` directives. These cannot be used together."
    },
    92: {
        file: "@apollo/client/core/QueryManager.js",
        condition: "this.localState",
        message: "Query '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured."
    },
    94: {
        file: "@apollo/client/core/QueryManager.js",
        condition: "this.localState",
        message: "Query '%s' contains `@client` fields but local state has not been configured."
    },
    95: {
        file: "@apollo/client/core/QueryManager.js",
        condition: "didEmitValue",
        message: "The link chain completed without emitting a value. This is likely unintentional and should be updated to emit a value before completing."
    },
    96: {
        file: "@apollo/client/cache/inmemory/entityStore.js",
        condition: "typeof dataId === \"string\"",
        message: "store.merge expects a string ID"
    },
    99: {
        file: "@apollo/client/cache/inmemory/key-extractor.js",
        condition: "extracted !== void 0",
        message: `Missing field '%s' while extracting keyFields from %s`
    },
    100: {
        file: "@apollo/client/cache/inmemory/policies.js",
        condition: "!old || old === which",
        message: `Cannot change root %s __typename more than once`
    },
    103: {
        file: "@apollo/client/cache/inmemory/policies.js",
        message: "Cannot automatically merge arrays"
    },
    104: {
        file: "@apollo/client/cache/inmemory/readFromStore.js",
        message: `No fragment named %s`
    },
    105: {
        file: "@apollo/client/cache/inmemory/readFromStore.js",
        condition: "!isReference(value)",
        message: `Missing selection set for object of type %s returned for query field %s`
    },
    106: {
        file: "@apollo/client/cache/inmemory/writeToStore.js",
        message: `Could not identify object %s`
    },
    108: {
        file: "@apollo/client/cache/inmemory/writeToStore.js",
        message: `No fragment named %s`
    }
};
const devDebug = {
    76: {
        file: "@apollo/client/core/ApolloClient.js",
        message: `In client.refetchQueries, Promise.all promise rejected with error %o`
    },
    83: {
        file: "@apollo/client/core/ObservableQuery.js",
        message: `Missing cache result fields: %o`
    }
};
const devLog = {};
const devWarn = {
    36: {
        file: "@apollo/client/react/hooks/internal/validateSuspenseHookOptions.js",
        message: "Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy."
    },
    40: {
        file: "@apollo/client/masking/maskDefinition.js",
        message: "Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead."
    },
    44: {
        file: "@apollo/client/masking/utils.js",
        message: "@unmask 'mode' argument does not support variables."
    },
    45: {
        file: "@apollo/client/masking/utils.js",
        message: "@unmask 'mode' argument must be of type string."
    },
    46: {
        file: "@apollo/client/masking/utils.js",
        message: "@unmask 'mode' argument does not recognize value '%s'."
    },
    50: {
        file: "@apollo/client/local-state/LocalState.js",
        message: "The '%s' resolver returned `undefined` instead of a value. This is likely a bug in the resolver. If you didn't mean to return a value, return `null` instead."
    },
    51: {
        file: "@apollo/client/local-state/LocalState.js",
        message: "The '%s' field had no cached value and only forced resolvers were run. The value was set to `null`."
    },
    52: {
        file: "@apollo/client/local-state/LocalState.js",
        message: "The '%s' field on object %o returned `undefined` instead of a value. The parent resolver did not include the property in the returned value and there was no resolver defined for the field."
    },
    56: {
        file: "@apollo/client/link/ws/index.js",
        message: "`WebSocketLink` uses the deprecated and unmaintained `subscriptions-transport-ws` library. This link is no longer maintained and will be removed in a future major version of Apollo Client. We recommend switching to `GraphQLWsLink` which uses the `graphql-ws` library to send GraphQL operations through WebSocket connections (https://the-guild.dev/graphql/ws)."
    },
    61: {
        file: "@apollo/client/link/core/ApolloLink.js",
        message: "[ApolloLink.split]: The test function returned a non-boolean value which could result in subtle bugs (e.g. such as using an `async` function which always returns a truthy value). Got `%o`."
    },
    62: {
        file: "@apollo/client/link/core/ApolloLink.js",
        message: "The terminating link provided to `ApolloLink.execute` called `forward` instead of handling the request. " + "This results in an observable that immediately completes and does not emit a value. " + "Please provide a terminating link that properly handles the request.\n\n" + "If you are using a split link, ensure each branch contains a terminating link that handles the request."
    },
    78: {
        file: "@apollo/client/core/ObservableQuery.js",
        message: `Called refetch(%o) for query %o, which does not declare a $variables variable.
Did you mean to call refetch(variables) instead of refetch({ variables })?`
    },
    82: {
        file: "@apollo/client/core/ObservableQuery.js",
        message: "Cannot poll on 'cache-only' query '%s' and as such, polling is disabled. Please use a different fetch policy."
    },
    87: {
        file: "@apollo/client/core/QueryManager.js",
        message: `Unknown query named "%s" requested in refetchQueries options.include array`
    },
    88: {
        file: "@apollo/client/core/QueryManager.js",
        message: `Unknown anonymous query requested in refetchQueries options.include array`
    },
    93: {
        file: "@apollo/client/core/QueryManager.js",
        message: '[%s]: Fragments masked by data masking are inaccessible when using fetch policy "no-cache". Please add `@unmask` to each fragment spread to access the data.'
    },
    97: {
        file: "@apollo/client/cache/inmemory/entityStore.js",
        message: "cache.modify: You are trying to write a Reference that is not part of the store: %o\n" + "Please make sure to set the `mergeIntoStore` parameter to `true` when creating a Reference that is not part of the store yet:\n" + "`toReference(object, true)`"
    },
    98: {
        file: "@apollo/client/cache/inmemory/entityStore.js",
        message: "cache.modify: Writing an array with a mix of both References and Objects will not result in the Objects being normalized correctly.\n" + "Please convert the object instance %o to a Reference before writing it to the cache by calling `toReference(object, true)`."
    },
    101: {
        file: "@apollo/client/cache/inmemory/policies.js",
        message: `Inferring subtype %s of supertype %s`
    },
    102: {
        file: "@apollo/client/cache/inmemory/policies.js",
        message: `Undefined 'from' passed to readField with arguments %s`
    },
    109: {
        file: "@apollo/client/cache/inmemory/writeToStore.js",
        message: `Cache data may be lost when replacing the %s field of a %s object.

This could cause additional (usually avoidable) network requests to fetch data that were otherwise cached.

To address this problem (which is not a bug in Apollo Client), %sdefine a custom merge function for the %s field, so InMemoryCache can safely merge these objects:

  existing: %o
  incoming: %o

For more information about these options, please refer to the documentation:

  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers
  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects
`
    },
    110: {
        file: "@apollo/client/cache/core/cache.js",
        message: "Could not identify object passed to `from` for '%s' fragment, either because the object is non-normalized or the key fields are missing. If you are masking this object, please ensure the key fields are requested by the parent object."
    }
};
const devError = {
    14: {
        file: "@apollo/client/utilities/internal/removeDirectivesFromDocument.js",
        message: `Could not find operation or fragment`
    },
    34: {
        file: "@apollo/client/react/hooks/useSyncExternalStore.js",
        message: "The result of getSnapshot should be cached to avoid an infinite loop"
    },
    81: {
        file: "@apollo/client/core/ObservableQuery.js",
        message: "Unhandled GraphQL subscription error"
    },
    107: {
        file: "@apollo/client/cache/inmemory/writeToStore.js",
        message: `Missing field '%s' while writing result %o`
    }
};
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/globals/maybe.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "maybe",
    ()=>maybe
]);
function maybe(thunk) {
    try {
        return thunk();
    } catch  {}
} //# sourceMappingURL=maybe.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/globals/global.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$maybe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/globals/maybe.js [app-ssr] (ecmascript)");
;
const __TURBOPACK__default__export__ = // long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$maybe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybe"])(()=>globalThis) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$maybe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybe"])(()=>window) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$maybe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybe"])(()=>self) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$maybe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybe"])(()=>/*TURBOPACK member replacement*/ __turbopack_context__.g) || // improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$maybe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybe"])(function() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$maybe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["maybe"].constructor("return this")();
});
 //# sourceMappingURL=global.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/globals/global.js [app-ssr] (ecmascript) <export default as global>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "global",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/globals/global.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/version.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "build",
    ()=>build,
    "version",
    ()=>version
]);
const version = "4.0.11";
const build = "esm"; //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/symbol.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApolloErrorMessageHandler",
    ()=>ApolloErrorMessageHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/version.js [app-ssr] (ecmascript)");
;
const ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"]); //# sourceMappingURL=symbol.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/setErrorMessageHandler.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setErrorMessageHandler",
    ()=>setErrorMessageHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__global$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/globals/global.js [app-ssr] (ecmascript) <export default as global>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$symbol$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/symbol.js [app-ssr] (ecmascript)");
;
;
function setErrorMessageHandler(handler) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__global$3e$__["global"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$symbol$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApolloErrorMessageHandler"]] = handler;
} //# sourceMappingURL=setErrorMessageHandler.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/loadErrorMessageHandler.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadErrorMessageHandler",
    ()=>loadErrorMessageHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__global$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/globals/global.js [app-ssr] (ecmascript) <export default as global>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$setErrorMessageHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/setErrorMessageHandler.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$symbol$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/symbol.js [app-ssr] (ecmascript)");
;
;
;
function loadErrorMessageHandler(...errorCodes) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$setErrorMessageHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setErrorMessageHandler"])(handler);
    for (const codes of errorCodes){
        Object.assign(handler, codes);
    }
    return handler;
}
const handler = (message, args)=>{
    if (typeof message === "number") {
        const definition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__global$3e$__["global"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$symbol$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApolloErrorMessageHandler"]][message];
        if (!message || !definition?.message) return;
        message = definition.message;
    }
    return args.reduce((msg, arg)=>msg.replace(/%[sdfo]/, String(arg)), String(message));
}; //# sourceMappingURL=loadErrorMessageHandler.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/loadDevMessages.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadDevMessages",
    ()=>loadDevMessages
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$invariantErrorCodes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/invariantErrorCodes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$loadErrorMessageHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/loadErrorMessageHandler.js [app-ssr] (ecmascript)");
;
;
function loadDevMessages() {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$loadErrorMessageHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["loadErrorMessageHandler"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$invariantErrorCodes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["devDebug"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$invariantErrorCodes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["devError"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$invariantErrorCodes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["devLog"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$invariantErrorCodes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["devWarn"]);
} //# sourceMappingURL=loadDevMessages.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/loadErrorMessages.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadErrorMessages",
    ()=>loadErrorMessages
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$invariantErrorCodes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/invariantErrorCodes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$loadErrorMessageHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/loadErrorMessageHandler.js [app-ssr] (ecmascript)");
;
;
function loadErrorMessages() {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$loadErrorMessageHandler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["loadErrorMessageHandler"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$invariantErrorCodes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"]);
} //# sourceMappingURL=loadErrorMessages.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/environment/index.development.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__DEV__",
    ()=>__DEV__
]);
const __DEV__ = true; //# sourceMappingURL=index.development.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/makeUniqueId.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "makeUniqueId",
    ()=>makeUniqueId
]);
const prefixCounts = new Map();
function makeUniqueId(prefix) {
    const count = prefixCounts.get(prefix) || 1;
    prefixCounts.set(prefix, count + 1);
    return `${prefix}:${count}:${Math.random().toString(36).slice(2)}`;
} //# sourceMappingURL=makeUniqueId.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/stringifyForDisplay.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stringifyForDisplay",
    ()=>stringifyForDisplay
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$makeUniqueId$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/makeUniqueId.js [app-ssr] (ecmascript)");
;
function stringifyForDisplay(value, space = 0) {
    const undefId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$makeUniqueId$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeUniqueId"])("stringifyForDisplay");
    return JSON.stringify(value, (_, value)=>{
        return value === void 0 ? undefId : value;
    }, space).split(JSON.stringify(undefId)).join("<undefined>");
} //# sourceMappingURL=stringifyForDisplay.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/invariant/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApolloErrorMessageHandler",
    ()=>ApolloErrorMessageHandler,
    "InvariantError",
    ()=>InvariantError,
    "invariant",
    ()=>invariant,
    "newInvariantError",
    ()=>newInvariantError,
    "setVerbosity",
    ()=>setVerbosity
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$environment$2f$index$2e$development$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/environment/index.development.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__global$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/globals/global.js [app-ssr] (ecmascript) <export default as global>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/version.js [app-ssr] (ecmascript)");
// eslint-disable-next-line local-rules/import-from-inside-other-export
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$stringifyForDisplay$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/internal/stringifyForDisplay.js [app-ssr] (ecmascript)");
;
;
;
;
const genericMessage = "Invariant Violation";
class InvariantError extends Error {
    constructor(message = genericMessage){
        super(message);
        this.name = genericMessage;
        Object.setPrototypeOf(this, InvariantError.prototype);
    }
}
const verbosityLevels = [
    "debug",
    "log",
    "warn",
    "error",
    "silent"
];
let verbosityLevel = verbosityLevels.indexOf(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$environment$2f$index$2e$development$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__DEV__"] ? "log" : "silent");
function invariant(condition, ...args) {
    if (!condition) {
        throw newInvariantError(...args);
    }
}
function wrapConsoleMethod(name) {
    return function(message, ...args) {
        if (verbosityLevels.indexOf(name) >= verbosityLevel) {
            // Default to console.log if this host environment happens not to provide
            // all the console.* methods we need.
            const method = console[name] || console.log;
            if (typeof message === "number") {
                const arg0 = message;
                message = getHandledErrorMsg(arg0);
                if (!message) {
                    message = getFallbackErrorMsg(arg0, args);
                    args = [];
                }
            }
            method(message, ...args);
        }
    };
}
invariant.debug = wrapConsoleMethod("debug");
invariant.log = wrapConsoleMethod("log");
invariant.warn = wrapConsoleMethod("warn");
invariant.error = wrapConsoleMethod("error");
function setVerbosity(level) {
    const old = verbosityLevels[verbosityLevel];
    verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
    return old;
}
function newInvariantError(message, ...optionalParams) {
    return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
}
const ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"]);
function stringify(arg) {
    if (typeof arg == "string") {
        return arg;
    }
    try {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$stringifyForDisplay$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringifyForDisplay"])(arg, 2).slice(0, 1000);
    } catch  {
        return "<non-serializable>";
    }
}
function getHandledErrorMsg(message, messageArgs = []) {
    if (!message) return;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__global$3e$__["global"][ApolloErrorMessageHandler] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$internal$2f$globals$2f$global$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__global$3e$__["global"][ApolloErrorMessageHandler](message, messageArgs.map(stringify));
}
function getFallbackErrorMsg(message, messageArgs = []) {
    if (!message) return;
    if (typeof message === "string") {
        return messageArgs.reduce((msg, arg)=>msg.replace(/%[sdfo]/, stringify(arg)), message);
    }
    return `An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#${encodeURIComponent(JSON.stringify({
        version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"],
        message,
        args: messageArgs.map(stringify)
    }))}`;
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/invariant/index.development.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "invariant",
    ()=>invariant
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$loadDevMessages$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/loadDevMessages.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$loadErrorMessages$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/dev/loadErrorMessages.js [app-ssr] (ecmascript)");
// eslint-disable-next-line local-rules/import-from-export
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$invariant$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/invariant/index.js [app-ssr] (ecmascript)");
;
;
;
const invariant = (()=>{
    // side effects in an IIFE
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$loadDevMessages$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["loadDevMessages"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$dev$2f$loadErrorMessages$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["loadErrorMessages"])();
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$invariant$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["invariant"];
})(); //# sourceMappingURL=index.development.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/react/context/ApolloContext.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getApolloContext",
    ()=>getApolloContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$invariant$2f$index$2e$development$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/invariant/index.development.js [app-ssr] (ecmascript) <locals>");
;
;
// To make sure Apollo Client doesn't create more than one React context
// (which can lead to problems like having an Apollo Client instance added
// in one context, then attempting to retrieve it from another different
// context), a single Apollo context is created and tracked in global state.
const contextKey = Symbol.for("__APOLLO_CONTEXT__");
function getApolloContext() {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$invariant$2f$index$2e$development$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["invariant"])("createContext" in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__, 37);
    let context = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.createContext[contextKey];
    if (!context) {
        Object.defineProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.createContext, contextKey, {
            value: context = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.createContext({}),
            enumerable: false,
            writable: false,
            configurable: true
        });
        context.displayName = "ApolloContext";
    }
    return context;
} //# sourceMappingURL=ApolloContext.js.map
}),
"[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/react/context/ApolloProvider.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApolloProvider",
    ()=>ApolloProvider
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.1_@babel+core@7.28.5_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$invariant$2f$index$2e$development$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/utilities/invariant/index.development.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$react$2f$context$2f$ApolloContext$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apollo+client@4.0.11_graphql-ws@6.0.6_graphql@16.12.0_ws@8.18.3__graphql@16.12.0_react_8462d6c287a671d7d2eb5f7744d98da0/node_modules/@apollo/client/react/context/ApolloContext.js [app-ssr] (ecmascript)");
;
;
;
const ApolloProvider = ({ client, children })=>{
    const ApolloContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$react$2f$context$2f$ApolloContext$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getApolloContext"])();
    const parentContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"](ApolloContext);
    const context = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"](()=>{
        return {
            ...parentContext,
            client: client || parentContext.client
        };
    }, [
        parentContext,
        client
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apollo$2b$client$40$4$2e$0$2e$11_graphql$2d$ws$40$6$2e$0$2e$6_graphql$40$16$2e$12$2e$0_ws$40$8$2e$18$2e$3_$5f$graphql$40$16$2e$12$2e$0_react_8462d6c287a671d7d2eb5f7744d98da0$2f$node_modules$2f40$apollo$2f$client$2f$utilities$2f$invariant$2f$index$2e$development$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["invariant"])(context.client, 38);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$1_$40$babel$2b$core$40$7$2e$28$2e$5_react$2d$dom$40$19$2e$2$2e$3_react$40$19$2e$2$2e$3_$5f$react$40$19$2e$2$2e$3$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createElement"](ApolloContext.Provider, {
        value: context
    }, children);
}; //# sourceMappingURL=ApolloProvider.js.map
}),
];

//# sourceMappingURL=node_modules__pnpm_01566910._.js.map